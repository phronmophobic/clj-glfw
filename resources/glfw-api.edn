{:functions ({:args [{:spelling "op", :type "unsigned int"} {:spelling "value", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float], :symbol "glAccum", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glAccum, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glAccum"} {:args [{:spelling "func", :type "unsigned int"} {:spelling "ref", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float], :symbol "glAlphaFunc", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glAlphaFunc, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glAlphaFunc"} {:args [{:spelling "n", :type "int"} {:spelling "textures", :type "const unsigned int *"} {:spelling "residences", :type "unsigned char *"}], :ret {:spelling "unsigned char"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char]], :symbol "glAreTexturesResident", :function/ret :coffi.mem/char, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glAreTexturesResident, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glAreTexturesResident"} {:args [{:spelling "i", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glArrayElement", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glArrayElement, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glArrayElement"} {:args [{:spelling "mode", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glBegin", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glBegin, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glBegin"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "texture", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glBindTexture", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glBindTexture, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glBindTexture"} {:args [{:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "xorig", :type "float"} {:spelling "yorig", :type "float"} {:spelling "xmove", :type "float"} {:spelling "ymove", :type "float"} {:spelling "bitmap", :type "const unsigned char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float [:coffi.mem/pointer :coffi.mem/char]], :symbol "glBitmap", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glBitmap, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glBitmap"} {:args [{:spelling "red", :type "float"} {:spelling "green", :type "float"} {:spelling "blue", :type "float"} {:spelling "alpha", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glBlendColor", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glBlendColor, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glBlendColor"} {:args [{:spelling "mode", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glBlendEquation", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glBlendEquation, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glBlendEquation"} {:args [{:spelling "modeRGB", :type "unsigned int"} {:spelling "modeAlpha", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glBlendEquationSeparate", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glBlendEquationSeparate, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glBlendEquationSeparate"} {:args [{:spelling "sfactor", :type "unsigned int"} {:spelling "dfactor", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glBlendFunc", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glBlendFunc, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glBlendFunc"} {:args [{:spelling "list", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glCallList", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCallList, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCallList"} {:args [{:spelling "n", :type "int"} {:spelling "type", :type "unsigned int"} {:spelling "lists", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glCallLists", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCallLists, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCallLists"} {:args [{:spelling "mask", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glClear", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glClear, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glClear"} {:args [{:spelling "red", :type "float"} {:spelling "green", :type "float"} {:spelling "blue", :type "float"} {:spelling "alpha", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glClearAccum", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glClearAccum, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glClearAccum"} {:args [{:spelling "red", :type "float"} {:spelling "green", :type "float"} {:spelling "blue", :type "float"} {:spelling "alpha", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glClearColor", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glClearColor, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glClearColor"} {:args [{:spelling "depth", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double], :symbol "glClearDepth", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glClearDepth, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glClearDepth"} {:args [{:spelling "c", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float], :symbol "glClearIndex", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glClearIndex, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glClearIndex"} {:args [{:spelling "s", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glClearStencil", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glClearStencil, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glClearStencil"} {:args [{:spelling "plane", :type "unsigned int"} {:spelling "equation", :type "const double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glClipPlane", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glClipPlane, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glClipPlane"} {:args [{:spelling "red", :type "signed char"} {:spelling "green", :type "signed char"} {:spelling "blue", :type "signed char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/char :coffi.mem/char :coffi.mem/char], :symbol "glColor3b", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3b, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3b"} {:args [{:spelling "v", :type "const signed char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "glColor3bv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3bv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3bv"} {:args [{:spelling "red", :type "double"} {:spelling "green", :type "double"} {:spelling "blue", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glColor3d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glColor3dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3dv"} {:args [{:spelling "red", :type "float"} {:spelling "green", :type "float"} {:spelling "blue", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glColor3f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glColor3fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3fv"} {:args [{:spelling "red", :type "int"} {:spelling "green", :type "int"} {:spelling "blue", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glColor3i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glColor3iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3iv"} {:args [{:spelling "red", :type "short"} {:spelling "green", :type "short"} {:spelling "blue", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glColor3s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glColor3sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3sv"} {:args [{:spelling "red", :type "unsigned char"} {:spelling "green", :type "unsigned char"} {:spelling "blue", :type "unsigned char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/char :coffi.mem/char :coffi.mem/char], :symbol "glColor3ub", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3ub, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3ub"} {:args [{:spelling "v", :type "const unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "glColor3ubv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3ubv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3ubv"} {:args [{:spelling "red", :type "unsigned int"} {:spelling "green", :type "unsigned int"} {:spelling "blue", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glColor3ui", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3ui, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3ui"} {:args [{:spelling "v", :type "const unsigned int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glColor3uiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3uiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3uiv"} {:args [{:spelling "red", :type "unsigned short"} {:spelling "green", :type "unsigned short"} {:spelling "blue", :type "unsigned short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glColor3us", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3us, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3us"} {:args [{:spelling "v", :type "const unsigned short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glColor3usv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor3usv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor3usv"} {:args [{:spelling "red", :type "signed char"} {:spelling "green", :type "signed char"} {:spelling "blue", :type "signed char"} {:spelling "alpha", :type "signed char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/char :coffi.mem/char :coffi.mem/char :coffi.mem/char], :symbol "glColor4b", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4b, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4b"} {:args [{:spelling "v", :type "const signed char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "glColor4bv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4bv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4bv"} {:args [{:spelling "red", :type "double"} {:spelling "green", :type "double"} {:spelling "blue", :type "double"} {:spelling "alpha", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glColor4d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glColor4dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4dv"} {:args [{:spelling "red", :type "float"} {:spelling "green", :type "float"} {:spelling "blue", :type "float"} {:spelling "alpha", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glColor4f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glColor4fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4fv"} {:args [{:spelling "red", :type "int"} {:spelling "green", :type "int"} {:spelling "blue", :type "int"} {:spelling "alpha", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glColor4i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glColor4iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4iv"} {:args [{:spelling "red", :type "short"} {:spelling "green", :type "short"} {:spelling "blue", :type "short"} {:spelling "alpha", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glColor4s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glColor4sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4sv"} {:args [{:spelling "red", :type "unsigned char"} {:spelling "green", :type "unsigned char"} {:spelling "blue", :type "unsigned char"} {:spelling "alpha", :type "unsigned char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/char :coffi.mem/char :coffi.mem/char :coffi.mem/char], :symbol "glColor4ub", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4ub, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4ub"} {:args [{:spelling "v", :type "const unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "glColor4ubv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4ubv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4ubv"} {:args [{:spelling "red", :type "unsigned int"} {:spelling "green", :type "unsigned int"} {:spelling "blue", :type "unsigned int"} {:spelling "alpha", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glColor4ui", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4ui, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4ui"} {:args [{:spelling "v", :type "const unsigned int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glColor4uiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4uiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4uiv"} {:args [{:spelling "red", :type "unsigned short"} {:spelling "green", :type "unsigned short"} {:spelling "blue", :type "unsigned short"} {:spelling "alpha", :type "unsigned short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glColor4us", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4us, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4us"} {:args [{:spelling "v", :type "const unsigned short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glColor4usv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColor4usv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColor4usv"} {:args [{:spelling "red", :type "unsigned char"} {:spelling "green", :type "unsigned char"} {:spelling "blue", :type "unsigned char"} {:spelling "alpha", :type "unsigned char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/char :coffi.mem/char :coffi.mem/char :coffi.mem/char], :symbol "glColorMask", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColorMask, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColorMask"} {:args [{:spelling "face", :type "unsigned int"} {:spelling "mode", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glColorMaterial", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColorMaterial, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColorMaterial"} {:args [{:spelling "size", :type "int"} {:spelling "type", :type "unsigned int"} {:spelling "stride", :type "int"} {:spelling "pointer", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glColorPointer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColorPointer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColorPointer"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "start", :type "int"} {:spelling "count", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "data", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glColorSubTable", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColorSubTable, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColorSubTable"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "internalformat", :type "unsigned int"} {:spelling "width", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "table", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glColorTable", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColorTable, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColorTable"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glColorTableParameterfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColorTableParameterfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColorTableParameterfv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glColorTableParameteriv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glColorTableParameteriv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glColorTableParameteriv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "internalformat", :type "unsigned int"} {:spelling "width", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "image", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glConvolutionFilter1D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glConvolutionFilter1D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glConvolutionFilter1D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "internalformat", :type "unsigned int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "image", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glConvolutionFilter2D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glConvolutionFilter2D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glConvolutionFilter2D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/float], :symbol "glConvolutionParameterf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glConvolutionParameterf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glConvolutionParameterf"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glConvolutionParameterfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glConvolutionParameterfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glConvolutionParameterfv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glConvolutionParameteri", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glConvolutionParameteri, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glConvolutionParameteri"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glConvolutionParameteriv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glConvolutionParameteriv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glConvolutionParameteriv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "start", :type "int"} {:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "width", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glCopyColorSubTable", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCopyColorSubTable, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCopyColorSubTable"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "internalformat", :type "unsigned int"} {:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "width", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glCopyColorTable", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCopyColorTable, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCopyColorTable"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "internalformat", :type "unsigned int"} {:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "width", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glCopyConvolutionFilter1D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCopyConvolutionFilter1D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCopyConvolutionFilter1D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "internalformat", :type "unsigned int"} {:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glCopyConvolutionFilter2D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCopyConvolutionFilter2D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCopyConvolutionFilter2D"} {:args [{:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "type", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glCopyPixels", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCopyPixels, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCopyPixels"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "internalformat", :type "unsigned int"} {:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "width", :type "int"} {:spelling "border", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glCopyTexImage1D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCopyTexImage1D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCopyTexImage1D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "internalformat", :type "unsigned int"} {:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "border", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glCopyTexImage2D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCopyTexImage2D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCopyTexImage2D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "xoffset", :type "int"} {:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "width", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glCopyTexSubImage1D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCopyTexSubImage1D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCopyTexSubImage1D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "xoffset", :type "int"} {:spelling "yoffset", :type "int"} {:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glCopyTexSubImage2D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCopyTexSubImage2D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCopyTexSubImage2D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "xoffset", :type "int"} {:spelling "yoffset", :type "int"} {:spelling "zoffset", :type "int"} {:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glCopyTexSubImage3D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCopyTexSubImage3D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCopyTexSubImage3D"} {:args [{:spelling "mode", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glCullFace", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCullFace, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCullFace"} {:args [{:spelling "list", :type "unsigned int"} {:spelling "range", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glDeleteLists", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDeleteLists, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDeleteLists"} {:args [{:spelling "n", :type "int"} {:spelling "textures", :type "const unsigned int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glDeleteTextures", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDeleteTextures, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDeleteTextures"} {:args [{:spelling "func", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glDepthFunc", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDepthFunc, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDepthFunc"} {:args [{:spelling "flag", :type "unsigned char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/char], :symbol "glDepthMask", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDepthMask, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDepthMask"} {:args [{:spelling "zNear", :type "double"} {:spelling "zFar", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double], :symbol "glDepthRange", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDepthRange, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDepthRange"} {:args [{:spelling "cap", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glDisable", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDisable, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDisable"} {:args [{:spelling "array", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glDisableClientState", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDisableClientState, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDisableClientState"} {:args [{:spelling "mode", :type "unsigned int"} {:spelling "first", :type "int"} {:spelling "count", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glDrawArrays", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDrawArrays, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDrawArrays"} {:args [{:spelling "mode", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glDrawBuffer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDrawBuffer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDrawBuffer"} {:args [{:spelling "mode", :type "unsigned int"} {:spelling "count", :type "int"} {:spelling "type", :type "unsigned int"} {:spelling "indices", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glDrawElements", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDrawElements, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDrawElements"} {:args [{:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "pixels", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glDrawPixels", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDrawPixels, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDrawPixels"} {:args [{:spelling "mode", :type "unsigned int"} {:spelling "start", :type "unsigned int"} {:spelling "end", :type "unsigned int"} {:spelling "count", :type "int"} {:spelling "type", :type "unsigned int"} {:spelling "indices", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glDrawRangeElements", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDrawRangeElements, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDrawRangeElements"} {:args [{:spelling "flag", :type "unsigned char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/char], :symbol "glEdgeFlag", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEdgeFlag, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEdgeFlag"} {:args [{:spelling "stride", :type "int"} {:spelling "pointer", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/pointer], :symbol "glEdgeFlagPointer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEdgeFlagPointer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEdgeFlagPointer"} {:args [{:spelling "flag", :type "const unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "glEdgeFlagv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEdgeFlagv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEdgeFlagv"} {:args [{:spelling "cap", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glEnable", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEnable, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEnable"} {:args [{:spelling "array", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glEnableClientState", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEnableClientState, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEnableClientState"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glEnd", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEnd, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEnd"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glEndList", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEndList, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEndList"} {:args [{:spelling "u", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double], :symbol "glEvalCoord1d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEvalCoord1d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEvalCoord1d"} {:args [{:spelling "u", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glEvalCoord1dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEvalCoord1dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEvalCoord1dv"} {:args [{:spelling "u", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float], :symbol "glEvalCoord1f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEvalCoord1f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEvalCoord1f"} {:args [{:spelling "u", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glEvalCoord1fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEvalCoord1fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEvalCoord1fv"} {:args [{:spelling "u", :type "double"} {:spelling "v", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double], :symbol "glEvalCoord2d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEvalCoord2d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEvalCoord2d"} {:args [{:spelling "u", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glEvalCoord2dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEvalCoord2dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEvalCoord2dv"} {:args [{:spelling "u", :type "float"} {:spelling "v", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float], :symbol "glEvalCoord2f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEvalCoord2f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEvalCoord2f"} {:args [{:spelling "u", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glEvalCoord2fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEvalCoord2fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEvalCoord2fv"} {:args [{:spelling "mode", :type "unsigned int"} {:spelling "i1", :type "int"} {:spelling "i2", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glEvalMesh1", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEvalMesh1, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEvalMesh1"} {:args [{:spelling "mode", :type "unsigned int"} {:spelling "i1", :type "int"} {:spelling "i2", :type "int"} {:spelling "j1", :type "int"} {:spelling "j2", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glEvalMesh2", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEvalMesh2, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEvalMesh2"} {:args [{:spelling "i", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glEvalPoint1", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEvalPoint1, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEvalPoint1"} {:args [{:spelling "i", :type "int"} {:spelling "j", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glEvalPoint2", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEvalPoint2, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEvalPoint2"} {:args [{:spelling "size", :type "int"} {:spelling "type", :type "unsigned int"} {:spelling "buffer", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glFeedbackBuffer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glFeedbackBuffer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glFeedbackBuffer"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glFinish", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glFinish, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glFinish"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glFlush", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glFlush, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glFlush"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "param", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float], :symbol "glFogf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glFogf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glFogf"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glFogfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glFogfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glFogfv"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "param", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glFogi", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glFogi, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glFogi"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glFogiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glFogiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glFogiv"} {:args [{:spelling "mode", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glFrontFace", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glFrontFace, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glFrontFace"} {:args [{:spelling "left", :type "double"} {:spelling "right", :type "double"} {:spelling "bottom", :type "double"} {:spelling "top", :type "double"} {:spelling "zNear", :type "double"} {:spelling "zFar", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glFrustum", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glFrustum, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glFrustum"} {:args [{:spelling "range", :type "int"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int], :symbol "glGenLists", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGenLists, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGenLists"} {:args [{:spelling "n", :type "int"} {:spelling "textures", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGenTextures", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGenTextures, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGenTextures"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "params", :type "unsigned char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]], :symbol "glGetBooleanv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetBooleanv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetBooleanv"} {:args [{:spelling "plane", :type "unsigned int"} {:spelling "equation", :type "double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glGetClipPlane", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetClipPlane, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetClipPlane"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "table", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glGetColorTable", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetColorTable, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetColorTable"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetColorTableParameterfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetColorTableParameterfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetColorTableParameterfv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetColorTableParameteriv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetColorTableParameteriv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetColorTableParameteriv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "image", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glGetConvolutionFilter", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetConvolutionFilter, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetConvolutionFilter"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetConvolutionParameterfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetConvolutionParameterfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetConvolutionParameterfv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetConvolutionParameteriv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetConvolutionParameteriv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetConvolutionParameteriv"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "params", :type "double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glGetDoublev", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetDoublev, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetDoublev"} {:args [], :ret {:spelling "unsigned int"}, :function/args [], :symbol "glGetError", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetError, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetError"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "params", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetFloatv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetFloatv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetFloatv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "reset", :type "unsigned char"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "values", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/char :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glGetHistogram", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetHistogram, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetHistogram"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetHistogramParameterfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetHistogramParameterfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetHistogramParameterfv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetHistogramParameteriv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetHistogramParameteriv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetHistogramParameteriv"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetIntegerv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetIntegerv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetIntegerv"} {:args [{:spelling "light", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetLightfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetLightfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetLightfv"} {:args [{:spelling "light", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetLightiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetLightiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetLightiv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "query", :type "unsigned int"} {:spelling "v", :type "double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glGetMapdv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetMapdv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetMapdv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "query", :type "unsigned int"} {:spelling "v", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetMapfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetMapfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetMapfv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "query", :type "unsigned int"} {:spelling "v", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetMapiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetMapiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetMapiv"} {:args [{:spelling "face", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetMaterialfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetMaterialfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetMaterialfv"} {:args [{:spelling "face", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetMaterialiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetMaterialiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetMaterialiv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "reset", :type "unsigned char"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "values", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/char :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glGetMinmax", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetMinmax, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetMinmax"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetMinmaxParameterfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetMinmaxParameterfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetMinmaxParameterfv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetMinmaxParameteriv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetMinmaxParameteriv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetMinmaxParameteriv"} {:args [{:spelling "map", :type "unsigned int"} {:spelling "values", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetPixelMapfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetPixelMapfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetPixelMapfv"} {:args [{:spelling "map", :type "unsigned int"} {:spelling "values", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetPixelMapuiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetPixelMapuiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetPixelMapuiv"} {:args [{:spelling "map", :type "unsigned int"} {:spelling "values", :type "unsigned short *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/short]], :symbol "glGetPixelMapusv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetPixelMapusv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetPixelMapusv"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "params", :type "void **"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/pointer]], :symbol "glGetPointerv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetPointerv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetPointerv"} {:args [{:spelling "mask", :type "unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "glGetPolygonStipple", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetPolygonStipple, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetPolygonStipple"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "row", :type "void *"} {:spelling "column", :type "void *"} {:spelling "span", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer :coffi.mem/pointer :coffi.mem/pointer], :symbol "glGetSeparableFilter", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetSeparableFilter, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetSeparableFilter"} {:args [{:spelling "name", :type "unsigned int"}], :ret {:spelling "const unsigned char *"}, :function/args [:coffi.mem/int], :symbol "glGetString", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetString, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetString"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetTexEnvfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetTexEnvfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetTexEnvfv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetTexEnviv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetTexEnviv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetTexEnviv"} {:args [{:spelling "coord", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glGetTexGendv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetTexGendv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetTexGendv"} {:args [{:spelling "coord", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetTexGenfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetTexGenfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetTexGenfv"} {:args [{:spelling "coord", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetTexGeniv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetTexGeniv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetTexGeniv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "pixels", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glGetTexImage", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetTexImage, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetTexImage"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetTexLevelParameterfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetTexLevelParameterfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetTexLevelParameterfv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetTexLevelParameteriv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetTexLevelParameteriv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetTexLevelParameteriv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetTexParameterfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetTexParameterfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetTexParameterfv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetTexParameteriv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetTexParameteriv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetTexParameteriv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "mode", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glHint", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glHint, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glHint"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "width", :type "int"} {:spelling "internalformat", :type "unsigned int"} {:spelling "sink", :type "unsigned char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/char], :symbol "glHistogram", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glHistogram, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glHistogram"} {:args [{:spelling "mask", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glIndexMask", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIndexMask, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIndexMask"} {:args [{:spelling "type", :type "unsigned int"} {:spelling "stride", :type "int"} {:spelling "pointer", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glIndexPointer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIndexPointer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIndexPointer"} {:args [{:spelling "c", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double], :symbol "glIndexd", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIndexd, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIndexd"} {:args [{:spelling "c", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glIndexdv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIndexdv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIndexdv"} {:args [{:spelling "c", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float], :symbol "glIndexf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIndexf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIndexf"} {:args [{:spelling "c", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glIndexfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIndexfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIndexfv"} {:args [{:spelling "c", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glIndexi", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIndexi, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIndexi"} {:args [{:spelling "c", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glIndexiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIndexiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIndexiv"} {:args [{:spelling "c", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short], :symbol "glIndexs", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIndexs, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIndexs"} {:args [{:spelling "c", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glIndexsv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIndexsv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIndexsv"} {:args [{:spelling "c", :type "unsigned char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/char], :symbol "glIndexub", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIndexub, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIndexub"} {:args [{:spelling "c", :type "const unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "glIndexubv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIndexubv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIndexubv"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glInitNames", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glInitNames, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glInitNames"} {:args [{:spelling "format", :type "unsigned int"} {:spelling "stride", :type "int"} {:spelling "pointer", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glInterleavedArrays", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glInterleavedArrays, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glInterleavedArrays"} {:args [{:spelling "cap", :type "unsigned int"}], :ret {:spelling "unsigned char"}, :function/args [:coffi.mem/int], :symbol "glIsEnabled", :function/ret :coffi.mem/char, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIsEnabled, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIsEnabled"} {:args [{:spelling "list", :type "unsigned int"}], :ret {:spelling "unsigned char"}, :function/args [:coffi.mem/int], :symbol "glIsList", :function/ret :coffi.mem/char, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIsList, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIsList"} {:args [{:spelling "texture", :type "unsigned int"}], :ret {:spelling "unsigned char"}, :function/args [:coffi.mem/int], :symbol "glIsTexture", :function/ret :coffi.mem/char, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIsTexture, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIsTexture"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "param", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float], :symbol "glLightModelf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLightModelf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLightModelf"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glLightModelfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLightModelfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLightModelfv"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "param", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glLightModeli", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLightModeli, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLightModeli"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glLightModeliv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLightModeliv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLightModeliv"} {:args [{:spelling "light", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "param", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/float], :symbol "glLightf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLightf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLightf"} {:args [{:spelling "light", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glLightfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLightfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLightfv"} {:args [{:spelling "light", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "param", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glLighti", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLighti, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLighti"} {:args [{:spelling "light", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glLightiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLightiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLightiv"} {:args [{:spelling "factor", :type "int"} {:spelling "pattern", :type "unsigned short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/short], :symbol "glLineStipple", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLineStipple, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLineStipple"} {:args [{:spelling "width", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float], :symbol "glLineWidth", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLineWidth, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLineWidth"} {:args [{:spelling "base", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glListBase", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glListBase, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glListBase"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glLoadIdentity", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLoadIdentity, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLoadIdentity"} {:args [{:spelling "m", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glLoadMatrixd", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLoadMatrixd, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLoadMatrixd"} {:args [{:spelling "m", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glLoadMatrixf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLoadMatrixf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLoadMatrixf"} {:args [{:spelling "name", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glLoadName", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLoadName, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLoadName"} {:args [{:spelling "opcode", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glLogicOp", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLogicOp, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLogicOp"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "u1", :type "double"} {:spelling "u2", :type "double"} {:spelling "stride", :type "int"} {:spelling "order", :type "int"} {:spelling "points", :type "const double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/double :coffi.mem/double :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glMap1d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMap1d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMap1d"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "u1", :type "float"} {:spelling "u2", :type "float"} {:spelling "stride", :type "int"} {:spelling "order", :type "int"} {:spelling "points", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float :coffi.mem/float :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glMap1f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMap1f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMap1f"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "u1", :type "double"} {:spelling "u2", :type "double"} {:spelling "ustride", :type "int"} {:spelling "uorder", :type "int"} {:spelling "v1", :type "double"} {:spelling "v2", :type "double"} {:spelling "vstride", :type "int"} {:spelling "vorder", :type "int"} {:spelling "points", :type "const double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/double :coffi.mem/double :coffi.mem/int :coffi.mem/int :coffi.mem/double :coffi.mem/double :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glMap2d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMap2d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMap2d"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "u1", :type "float"} {:spelling "u2", :type "float"} {:spelling "ustride", :type "int"} {:spelling "uorder", :type "int"} {:spelling "v1", :type "float"} {:spelling "v2", :type "float"} {:spelling "vstride", :type "int"} {:spelling "vorder", :type "int"} {:spelling "points", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float :coffi.mem/float :coffi.mem/int :coffi.mem/int :coffi.mem/float :coffi.mem/float :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glMap2f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMap2f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMap2f"} {:args [{:spelling "un", :type "int"} {:spelling "u1", :type "double"} {:spelling "u2", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/double :coffi.mem/double], :symbol "glMapGrid1d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMapGrid1d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMapGrid1d"} {:args [{:spelling "un", :type "int"} {:spelling "u1", :type "float"} {:spelling "u2", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float :coffi.mem/float], :symbol "glMapGrid1f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMapGrid1f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMapGrid1f"} {:args [{:spelling "un", :type "int"} {:spelling "u1", :type "double"} {:spelling "u2", :type "double"} {:spelling "vn", :type "int"} {:spelling "v1", :type "double"} {:spelling "v2", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/double :coffi.mem/double :coffi.mem/int :coffi.mem/double :coffi.mem/double], :symbol "glMapGrid2d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMapGrid2d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMapGrid2d"} {:args [{:spelling "un", :type "int"} {:spelling "u1", :type "float"} {:spelling "u2", :type "float"} {:spelling "vn", :type "int"} {:spelling "v1", :type "float"} {:spelling "v2", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float :coffi.mem/float :coffi.mem/int :coffi.mem/float :coffi.mem/float], :symbol "glMapGrid2f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMapGrid2f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMapGrid2f"} {:args [{:spelling "face", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "param", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/float], :symbol "glMaterialf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMaterialf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMaterialf"} {:args [{:spelling "face", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glMaterialfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMaterialfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMaterialfv"} {:args [{:spelling "face", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "param", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glMateriali", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMateriali, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMateriali"} {:args [{:spelling "face", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glMaterialiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMaterialiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMaterialiv"} {:args [{:spelling "mode", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glMatrixMode", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMatrixMode, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMatrixMode"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "internalformat", :type "unsigned int"} {:spelling "sink", :type "unsigned char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/char], :symbol "glMinmax", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMinmax, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMinmax"} {:args [{:spelling "m", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glMultMatrixd", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultMatrixd, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultMatrixd"} {:args [{:spelling "m", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glMultMatrixf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultMatrixf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultMatrixf"} {:args [{:spelling "list", :type "unsigned int"} {:spelling "mode", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glNewList", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glNewList, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glNewList"} {:args [{:spelling "nx", :type "signed char"} {:spelling "ny", :type "signed char"} {:spelling "nz", :type "signed char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/char :coffi.mem/char :coffi.mem/char], :symbol "glNormal3b", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glNormal3b, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glNormal3b"} {:args [{:spelling "v", :type "const signed char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "glNormal3bv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glNormal3bv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glNormal3bv"} {:args [{:spelling "nx", :type "double"} {:spelling "ny", :type "double"} {:spelling "nz", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glNormal3d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glNormal3d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glNormal3d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glNormal3dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glNormal3dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glNormal3dv"} {:args [{:spelling "nx", :type "float"} {:spelling "ny", :type "float"} {:spelling "nz", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glNormal3f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glNormal3f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glNormal3f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glNormal3fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glNormal3fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glNormal3fv"} {:args [{:spelling "nx", :type "int"} {:spelling "ny", :type "int"} {:spelling "nz", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glNormal3i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glNormal3i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glNormal3i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glNormal3iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glNormal3iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glNormal3iv"} {:args [{:spelling "nx", :type "short"} {:spelling "ny", :type "short"} {:spelling "nz", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glNormal3s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glNormal3s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glNormal3s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glNormal3sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glNormal3sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glNormal3sv"} {:args [{:spelling "type", :type "unsigned int"} {:spelling "stride", :type "int"} {:spelling "pointer", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glNormalPointer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glNormalPointer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glNormalPointer"} {:args [{:spelling "left", :type "double"} {:spelling "right", :type "double"} {:spelling "bottom", :type "double"} {:spelling "top", :type "double"} {:spelling "zNear", :type "double"} {:spelling "zFar", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glOrtho", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glOrtho, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glOrtho"} {:args [{:spelling "token", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float], :symbol "glPassThrough", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPassThrough, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPassThrough"} {:args [{:spelling "map", :type "unsigned int"} {:spelling "mapsize", :type "int"} {:spelling "values", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glPixelMapfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPixelMapfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPixelMapfv"} {:args [{:spelling "map", :type "unsigned int"} {:spelling "mapsize", :type "int"} {:spelling "values", :type "const unsigned int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glPixelMapuiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPixelMapuiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPixelMapuiv"} {:args [{:spelling "map", :type "unsigned int"} {:spelling "mapsize", :type "int"} {:spelling "values", :type "const unsigned short *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/short]], :symbol "glPixelMapusv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPixelMapusv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPixelMapusv"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "param", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float], :symbol "glPixelStoref", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPixelStoref, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPixelStoref"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "param", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glPixelStorei", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPixelStorei, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPixelStorei"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "param", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float], :symbol "glPixelTransferf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPixelTransferf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPixelTransferf"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "param", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glPixelTransferi", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPixelTransferi, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPixelTransferi"} {:args [{:spelling "xfactor", :type "float"} {:spelling "yfactor", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float], :symbol "glPixelZoom", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPixelZoom, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPixelZoom"} {:args [{:spelling "size", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float], :symbol "glPointSize", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPointSize, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPointSize"} {:args [{:spelling "face", :type "unsigned int"} {:spelling "mode", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glPolygonMode", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPolygonMode, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPolygonMode"} {:args [{:spelling "factor", :type "float"} {:spelling "units", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float], :symbol "glPolygonOffset", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPolygonOffset, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPolygonOffset"} {:args [{:spelling "mask", :type "const unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "glPolygonStipple", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPolygonStipple, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPolygonStipple"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glPopAttrib", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPopAttrib, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPopAttrib"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glPopClientAttrib", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPopClientAttrib, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPopClientAttrib"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glPopMatrix", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPopMatrix, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPopMatrix"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glPopName", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPopName, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPopName"} {:args [{:spelling "n", :type "int"} {:spelling "textures", :type "const unsigned int *"} {:spelling "priorities", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/float]], :symbol "glPrioritizeTextures", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPrioritizeTextures, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPrioritizeTextures"} {:args [{:spelling "mask", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glPushAttrib", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPushAttrib, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPushAttrib"} {:args [{:spelling "mask", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glPushClientAttrib", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPushClientAttrib, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPushClientAttrib"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glPushMatrix", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPushMatrix, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPushMatrix"} {:args [{:spelling "name", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glPushName", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPushName, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPushName"} {:args [{:spelling "x", :type "double"} {:spelling "y", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double], :symbol "glRasterPos2d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos2d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos2d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glRasterPos2dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos2dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos2dv"} {:args [{:spelling "x", :type "float"} {:spelling "y", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float], :symbol "glRasterPos2f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos2f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos2f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glRasterPos2fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos2fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos2fv"} {:args [{:spelling "x", :type "int"} {:spelling "y", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glRasterPos2i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos2i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos2i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glRasterPos2iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos2iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos2iv"} {:args [{:spelling "x", :type "short"} {:spelling "y", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short], :symbol "glRasterPos2s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos2s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos2s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glRasterPos2sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos2sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos2sv"} {:args [{:spelling "x", :type "double"} {:spelling "y", :type "double"} {:spelling "z", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glRasterPos3d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos3d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos3d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glRasterPos3dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos3dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos3dv"} {:args [{:spelling "x", :type "float"} {:spelling "y", :type "float"} {:spelling "z", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glRasterPos3f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos3f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos3f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glRasterPos3fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos3fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos3fv"} {:args [{:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "z", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glRasterPos3i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos3i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos3i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glRasterPos3iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos3iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos3iv"} {:args [{:spelling "x", :type "short"} {:spelling "y", :type "short"} {:spelling "z", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glRasterPos3s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos3s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos3s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glRasterPos3sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos3sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos3sv"} {:args [{:spelling "x", :type "double"} {:spelling "y", :type "double"} {:spelling "z", :type "double"} {:spelling "w", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glRasterPos4d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos4d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos4d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glRasterPos4dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos4dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos4dv"} {:args [{:spelling "x", :type "float"} {:spelling "y", :type "float"} {:spelling "z", :type "float"} {:spelling "w", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glRasterPos4f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos4f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos4f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glRasterPos4fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos4fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos4fv"} {:args [{:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "z", :type "int"} {:spelling "w", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glRasterPos4i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos4i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos4i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glRasterPos4iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos4iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos4iv"} {:args [{:spelling "x", :type "short"} {:spelling "y", :type "short"} {:spelling "z", :type "short"} {:spelling "w", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glRasterPos4s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos4s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos4s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glRasterPos4sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRasterPos4sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRasterPos4sv"} {:args [{:spelling "mode", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glReadBuffer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glReadBuffer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glReadBuffer"} {:args [{:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "pixels", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glReadPixels", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glReadPixels, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glReadPixels"} {:args [{:spelling "x1", :type "double"} {:spelling "y1", :type "double"} {:spelling "x2", :type "double"} {:spelling "y2", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glRectd", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRectd, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRectd"} {:args [{:spelling "v1", :type "const double *"} {:spelling "v2", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double] [:coffi.mem/pointer :coffi.mem/double]], :symbol "glRectdv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRectdv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRectdv"} {:args [{:spelling "x1", :type "float"} {:spelling "y1", :type "float"} {:spelling "x2", :type "float"} {:spelling "y2", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glRectf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRectf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRectf"} {:args [{:spelling "v1", :type "const float *"} {:spelling "v2", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float] [:coffi.mem/pointer :coffi.mem/float]], :symbol "glRectfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRectfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRectfv"} {:args [{:spelling "x1", :type "int"} {:spelling "y1", :type "int"} {:spelling "x2", :type "int"} {:spelling "y2", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glRecti", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRecti, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRecti"} {:args [{:spelling "v1", :type "const int *"} {:spelling "v2", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "glRectiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRectiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRectiv"} {:args [{:spelling "x1", :type "short"} {:spelling "y1", :type "short"} {:spelling "x2", :type "short"} {:spelling "y2", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glRects", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRects, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRects"} {:args [{:spelling "v1", :type "const short *"} {:spelling "v2", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short] [:coffi.mem/pointer :coffi.mem/short]], :symbol "glRectsv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRectsv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRectsv"} {:args [{:spelling "mode", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "glRenderMode", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRenderMode, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRenderMode"} {:args [{:spelling "target", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glResetHistogram", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glResetHistogram, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glResetHistogram"} {:args [{:spelling "target", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glResetMinmax", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glResetMinmax, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glResetMinmax"} {:args [{:spelling "angle", :type "double"} {:spelling "x", :type "double"} {:spelling "y", :type "double"} {:spelling "z", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glRotated", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRotated, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRotated"} {:args [{:spelling "angle", :type "float"} {:spelling "x", :type "float"} {:spelling "y", :type "float"} {:spelling "z", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glRotatef", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glRotatef, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glRotatef"} {:args [{:spelling "x", :type "double"} {:spelling "y", :type "double"} {:spelling "z", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glScaled", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glScaled, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glScaled"} {:args [{:spelling "x", :type "float"} {:spelling "y", :type "float"} {:spelling "z", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glScalef", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glScalef, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glScalef"} {:args [{:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glScissor", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glScissor, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glScissor"} {:args [{:spelling "size", :type "int"} {:spelling "buffer", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glSelectBuffer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSelectBuffer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSelectBuffer"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "internalformat", :type "unsigned int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "row", :type "const void *"} {:spelling "column", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer :coffi.mem/pointer], :symbol "glSeparableFilter2D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSeparableFilter2D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSeparableFilter2D"} {:args [{:spelling "mode", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glShadeModel", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glShadeModel, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glShadeModel"} {:args [{:spelling "func", :type "unsigned int"} {:spelling "ref", :type "int"} {:spelling "mask", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glStencilFunc", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glStencilFunc, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glStencilFunc"} {:args [{:spelling "mask", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glStencilMask", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glStencilMask, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glStencilMask"} {:args [{:spelling "fail", :type "unsigned int"} {:spelling "zfail", :type "unsigned int"} {:spelling "zpass", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glStencilOp", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glStencilOp, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glStencilOp"} {:args [{:spelling "s", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double], :symbol "glTexCoord1d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord1d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord1d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glTexCoord1dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord1dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord1dv"} {:args [{:spelling "s", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float], :symbol "glTexCoord1f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord1f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord1f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glTexCoord1fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord1fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord1fv"} {:args [{:spelling "s", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glTexCoord1i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord1i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord1i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glTexCoord1iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord1iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord1iv"} {:args [{:spelling "s", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short], :symbol "glTexCoord1s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord1s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord1s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glTexCoord1sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord1sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord1sv"} {:args [{:spelling "s", :type "double"} {:spelling "t", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double], :symbol "glTexCoord2d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord2d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord2d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glTexCoord2dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord2dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord2dv"} {:args [{:spelling "s", :type "float"} {:spelling "t", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float], :symbol "glTexCoord2f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord2f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord2f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glTexCoord2fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord2fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord2fv"} {:args [{:spelling "s", :type "int"} {:spelling "t", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glTexCoord2i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord2i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord2i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glTexCoord2iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord2iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord2iv"} {:args [{:spelling "s", :type "short"} {:spelling "t", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short], :symbol "glTexCoord2s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord2s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord2s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glTexCoord2sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord2sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord2sv"} {:args [{:spelling "s", :type "double"} {:spelling "t", :type "double"} {:spelling "r", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glTexCoord3d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord3d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord3d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glTexCoord3dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord3dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord3dv"} {:args [{:spelling "s", :type "float"} {:spelling "t", :type "float"} {:spelling "r", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glTexCoord3f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord3f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord3f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glTexCoord3fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord3fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord3fv"} {:args [{:spelling "s", :type "int"} {:spelling "t", :type "int"} {:spelling "r", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glTexCoord3i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord3i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord3i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glTexCoord3iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord3iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord3iv"} {:args [{:spelling "s", :type "short"} {:spelling "t", :type "short"} {:spelling "r", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glTexCoord3s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord3s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord3s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glTexCoord3sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord3sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord3sv"} {:args [{:spelling "s", :type "double"} {:spelling "t", :type "double"} {:spelling "r", :type "double"} {:spelling "q", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glTexCoord4d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord4d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord4d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glTexCoord4dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord4dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord4dv"} {:args [{:spelling "s", :type "float"} {:spelling "t", :type "float"} {:spelling "r", :type "float"} {:spelling "q", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glTexCoord4f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord4f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord4f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glTexCoord4fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord4fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord4fv"} {:args [{:spelling "s", :type "int"} {:spelling "t", :type "int"} {:spelling "r", :type "int"} {:spelling "q", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glTexCoord4i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord4i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord4i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glTexCoord4iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord4iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord4iv"} {:args [{:spelling "s", :type "short"} {:spelling "t", :type "short"} {:spelling "r", :type "short"} {:spelling "q", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glTexCoord4s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord4s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord4s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glTexCoord4sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoord4sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoord4sv"} {:args [{:spelling "size", :type "int"} {:spelling "type", :type "unsigned int"} {:spelling "stride", :type "int"} {:spelling "pointer", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glTexCoordPointer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexCoordPointer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexCoordPointer"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "param", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/float], :symbol "glTexEnvf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexEnvf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexEnvf"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glTexEnvfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexEnvfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexEnvfv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "param", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glTexEnvi", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexEnvi, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexEnvi"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glTexEnviv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexEnviv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexEnviv"} {:args [{:spelling "coord", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "param", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/double], :symbol "glTexGend", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexGend, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexGend"} {:args [{:spelling "coord", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glTexGendv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexGendv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexGendv"} {:args [{:spelling "coord", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "param", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/float], :symbol "glTexGenf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexGenf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexGenf"} {:args [{:spelling "coord", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glTexGenfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexGenfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexGenfv"} {:args [{:spelling "coord", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "param", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glTexGeni", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexGeni, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexGeni"} {:args [{:spelling "coord", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glTexGeniv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexGeniv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexGeniv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "internalformat", :type "int"} {:spelling "width", :type "int"} {:spelling "border", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "pixels", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glTexImage1D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexImage1D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexImage1D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "internalformat", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "border", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "pixels", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glTexImage2D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexImage2D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexImage2D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "internalformat", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "depth", :type "int"} {:spelling "border", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "pixels", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glTexImage3D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexImage3D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexImage3D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "param", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/float], :symbol "glTexParameterf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexParameterf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexParameterf"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glTexParameterfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexParameterfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexParameterfv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "param", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glTexParameteri", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexParameteri, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexParameteri"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glTexParameteriv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexParameteriv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexParameteriv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "xoffset", :type "int"} {:spelling "width", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "pixels", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glTexSubImage1D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexSubImage1D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexSubImage1D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "xoffset", :type "int"} {:spelling "yoffset", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "pixels", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glTexSubImage2D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexSubImage2D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexSubImage2D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "xoffset", :type "int"} {:spelling "yoffset", :type "int"} {:spelling "zoffset", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "depth", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "type", :type "unsigned int"} {:spelling "pixels", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glTexSubImage3D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTexSubImage3D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTexSubImage3D"} {:args [{:spelling "x", :type "double"} {:spelling "y", :type "double"} {:spelling "z", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glTranslated", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTranslated, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTranslated"} {:args [{:spelling "x", :type "float"} {:spelling "y", :type "float"} {:spelling "z", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glTranslatef", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glTranslatef, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glTranslatef"} {:args [{:spelling "x", :type "double"} {:spelling "y", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double], :symbol "glVertex2d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex2d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex2d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glVertex2dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex2dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex2dv"} {:args [{:spelling "x", :type "float"} {:spelling "y", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float], :symbol "glVertex2f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex2f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex2f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glVertex2fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex2fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex2fv"} {:args [{:spelling "x", :type "int"} {:spelling "y", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glVertex2i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex2i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex2i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glVertex2iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex2iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex2iv"} {:args [{:spelling "x", :type "short"} {:spelling "y", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short], :symbol "glVertex2s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex2s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex2s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glVertex2sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex2sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex2sv"} {:args [{:spelling "x", :type "double"} {:spelling "y", :type "double"} {:spelling "z", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glVertex3d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex3d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex3d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glVertex3dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex3dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex3dv"} {:args [{:spelling "x", :type "float"} {:spelling "y", :type "float"} {:spelling "z", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glVertex3f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex3f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex3f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glVertex3fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex3fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex3fv"} {:args [{:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "z", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glVertex3i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex3i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex3i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glVertex3iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex3iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex3iv"} {:args [{:spelling "x", :type "short"} {:spelling "y", :type "short"} {:spelling "z", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glVertex3s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex3s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex3s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glVertex3sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex3sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex3sv"} {:args [{:spelling "x", :type "double"} {:spelling "y", :type "double"} {:spelling "z", :type "double"} {:spelling "w", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glVertex4d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex4d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex4d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glVertex4dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex4dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex4dv"} {:args [{:spelling "x", :type "float"} {:spelling "y", :type "float"} {:spelling "z", :type "float"} {:spelling "w", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glVertex4f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex4f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex4f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glVertex4fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex4fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex4fv"} {:args [{:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "z", :type "int"} {:spelling "w", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glVertex4i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex4i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex4i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glVertex4iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex4iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex4iv"} {:args [{:spelling "x", :type "short"} {:spelling "y", :type "short"} {:spelling "z", :type "short"} {:spelling "w", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glVertex4s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex4s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex4s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glVertex4sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertex4sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertex4sv"} {:args [{:spelling "size", :type "int"} {:spelling "type", :type "unsigned int"} {:spelling "stride", :type "int"} {:spelling "pointer", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glVertexPointer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexPointer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexPointer"} {:args [{:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glViewport", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glViewport, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glViewport"} {:args [{:spelling "value", :type "float"} {:spelling "invert", :type "unsigned char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/char], :symbol "glSampleCoverage", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSampleCoverage, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSampleCoverage"} {:args [{:spelling "m", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glLoadTransposeMatrixf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLoadTransposeMatrixf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLoadTransposeMatrixf"} {:args [{:spelling "m", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glLoadTransposeMatrixd", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLoadTransposeMatrixd, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLoadTransposeMatrixd"} {:args [{:spelling "m", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glMultTransposeMatrixf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultTransposeMatrixf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultTransposeMatrixf"} {:args [{:spelling "m", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glMultTransposeMatrixd", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultTransposeMatrixd, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultTransposeMatrixd"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "internalformat", :type "unsigned int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "depth", :type "int"} {:spelling "border", :type "int"} {:spelling "imageSize", :type "int"} {:spelling "data", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glCompressedTexImage3D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCompressedTexImage3D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCompressedTexImage3D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "internalformat", :type "unsigned int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "border", :type "int"} {:spelling "imageSize", :type "int"} {:spelling "data", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glCompressedTexImage2D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCompressedTexImage2D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCompressedTexImage2D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "internalformat", :type "unsigned int"} {:spelling "width", :type "int"} {:spelling "border", :type "int"} {:spelling "imageSize", :type "int"} {:spelling "data", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glCompressedTexImage1D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCompressedTexImage1D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCompressedTexImage1D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "xoffset", :type "int"} {:spelling "yoffset", :type "int"} {:spelling "zoffset", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "depth", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "imageSize", :type "int"} {:spelling "data", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glCompressedTexSubImage3D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCompressedTexSubImage3D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCompressedTexSubImage3D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "xoffset", :type "int"} {:spelling "yoffset", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "imageSize", :type "int"} {:spelling "data", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glCompressedTexSubImage2D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCompressedTexSubImage2D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCompressedTexSubImage2D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "level", :type "int"} {:spelling "xoffset", :type "int"} {:spelling "width", :type "int"} {:spelling "format", :type "unsigned int"} {:spelling "imageSize", :type "int"} {:spelling "data", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glCompressedTexSubImage1D", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCompressedTexSubImage1D, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCompressedTexSubImage1D"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "lod", :type "int"} {:spelling "img", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glGetCompressedTexImage", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetCompressedTexImage, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetCompressedTexImage"} {:args [{:spelling "texture", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glActiveTexture", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glActiveTexture, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glActiveTexture"} {:args [{:spelling "texture", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glClientActiveTexture", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glClientActiveTexture, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glClientActiveTexture"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/double], :symbol "glMultiTexCoord1d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord1d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord1d"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glMultiTexCoord1dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord1dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord1dv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float], :symbol "glMultiTexCoord1f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord1f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord1f"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glMultiTexCoord1fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord1fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord1fv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glMultiTexCoord1i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord1i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord1i"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glMultiTexCoord1iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord1iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord1iv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/short], :symbol "glMultiTexCoord1s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord1s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord1s"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/short]], :symbol "glMultiTexCoord1sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord1sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord1sv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "double"} {:spelling "t", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/double :coffi.mem/double], :symbol "glMultiTexCoord2d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord2d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord2d"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glMultiTexCoord2dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord2dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord2dv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "float"} {:spelling "t", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float :coffi.mem/float], :symbol "glMultiTexCoord2f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord2f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord2f"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glMultiTexCoord2fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord2fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord2fv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "int"} {:spelling "t", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glMultiTexCoord2i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord2i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord2i"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glMultiTexCoord2iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord2iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord2iv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "short"} {:spelling "t", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/short :coffi.mem/short], :symbol "glMultiTexCoord2s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord2s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord2s"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/short]], :symbol "glMultiTexCoord2sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord2sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord2sv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "double"} {:spelling "t", :type "double"} {:spelling "r", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glMultiTexCoord3d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord3d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord3d"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glMultiTexCoord3dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord3dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord3dv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "float"} {:spelling "t", :type "float"} {:spelling "r", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glMultiTexCoord3f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord3f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord3f"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glMultiTexCoord3fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord3fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord3fv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "int"} {:spelling "t", :type "int"} {:spelling "r", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glMultiTexCoord3i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord3i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord3i"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glMultiTexCoord3iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord3iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord3iv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "short"} {:spelling "t", :type "short"} {:spelling "r", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glMultiTexCoord3s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord3s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord3s"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/short]], :symbol "glMultiTexCoord3sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord3sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord3sv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "double"} {:spelling "t", :type "double"} {:spelling "r", :type "double"} {:spelling "q", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glMultiTexCoord4d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord4d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord4d"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glMultiTexCoord4dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord4dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord4dv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "float"} {:spelling "t", :type "float"} {:spelling "r", :type "float"} {:spelling "q", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glMultiTexCoord4f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord4f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord4f"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glMultiTexCoord4fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord4fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord4fv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "int"} {:spelling "t", :type "int"} {:spelling "r", :type "int"} {:spelling "q", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glMultiTexCoord4i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord4i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord4i"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glMultiTexCoord4iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord4iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord4iv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "s", :type "short"} {:spelling "t", :type "short"} {:spelling "r", :type "short"} {:spelling "q", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/short :coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glMultiTexCoord4s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord4s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord4s"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/short]], :symbol "glMultiTexCoord4sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiTexCoord4sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiTexCoord4sv"} {:args [{:spelling "coord", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float], :symbol "glFogCoordf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glFogCoordf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glFogCoordf"} {:args [{:spelling "coord", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glFogCoordfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glFogCoordfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glFogCoordfv"} {:args [{:spelling "coord", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double], :symbol "glFogCoordd", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glFogCoordd, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glFogCoordd"} {:args [{:spelling "coord", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glFogCoorddv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glFogCoorddv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glFogCoorddv"} {:args [{:spelling "type", :type "unsigned int"} {:spelling "stride", :type "int"} {:spelling "pointer", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glFogCoordPointer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glFogCoordPointer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glFogCoordPointer"} {:args [{:spelling "red", :type "signed char"} {:spelling "green", :type "signed char"} {:spelling "blue", :type "signed char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/char :coffi.mem/char :coffi.mem/char], :symbol "glSecondaryColor3b", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3b, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3b"} {:args [{:spelling "v", :type "const signed char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "glSecondaryColor3bv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3bv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3bv"} {:args [{:spelling "red", :type "double"} {:spelling "green", :type "double"} {:spelling "blue", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glSecondaryColor3d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glSecondaryColor3dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3dv"} {:args [{:spelling "red", :type "float"} {:spelling "green", :type "float"} {:spelling "blue", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glSecondaryColor3f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glSecondaryColor3fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3fv"} {:args [{:spelling "red", :type "int"} {:spelling "green", :type "int"} {:spelling "blue", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glSecondaryColor3i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glSecondaryColor3iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3iv"} {:args [{:spelling "red", :type "short"} {:spelling "green", :type "short"} {:spelling "blue", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glSecondaryColor3s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glSecondaryColor3sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3sv"} {:args [{:spelling "red", :type "unsigned char"} {:spelling "green", :type "unsigned char"} {:spelling "blue", :type "unsigned char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/char :coffi.mem/char :coffi.mem/char], :symbol "glSecondaryColor3ub", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3ub, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3ub"} {:args [{:spelling "v", :type "const unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "glSecondaryColor3ubv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3ubv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3ubv"} {:args [{:spelling "red", :type "unsigned int"} {:spelling "green", :type "unsigned int"} {:spelling "blue", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glSecondaryColor3ui", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3ui, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3ui"} {:args [{:spelling "v", :type "const unsigned int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glSecondaryColor3uiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3uiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3uiv"} {:args [{:spelling "red", :type "unsigned short"} {:spelling "green", :type "unsigned short"} {:spelling "blue", :type "unsigned short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glSecondaryColor3us", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3us, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3us"} {:args [{:spelling "v", :type "const unsigned short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glSecondaryColor3usv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColor3usv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColor3usv"} {:args [{:spelling "size", :type "int"} {:spelling "type", :type "unsigned int"} {:spelling "stride", :type "int"} {:spelling "pointer", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "glSecondaryColorPointer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glSecondaryColorPointer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glSecondaryColorPointer"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "param", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float], :symbol "glPointParameterf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPointParameterf, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPointParameterf"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glPointParameterfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPointParameterfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPointParameterfv"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "param", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glPointParameteri", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPointParameteri, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPointParameteri"} {:args [{:spelling "pname", :type "unsigned int"} {:spelling "params", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glPointParameteriv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glPointParameteriv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glPointParameteriv"} {:args [{:spelling "srcRGB", :type "unsigned int"} {:spelling "dstRGB", :type "unsigned int"} {:spelling "srcAlpha", :type "unsigned int"} {:spelling "dstAlpha", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glBlendFuncSeparate", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glBlendFuncSeparate, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glBlendFuncSeparate"} {:args [{:spelling "mode", :type "unsigned int"} {:spelling "first", :type "const int *"} {:spelling "count", :type "const int *"} {:spelling "primcount", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int], :symbol "glMultiDrawArrays", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiDrawArrays, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiDrawArrays"} {:args [{:spelling "mode", :type "unsigned int"} {:spelling "count", :type "const int *"} {:spelling "type", :type "unsigned int"} {:spelling "indices", :type "const void *const *"} {:spelling "primcount", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/int], :symbol "glMultiDrawElements", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMultiDrawElements, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMultiDrawElements"} {:args [{:spelling "x", :type "double"} {:spelling "y", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double], :symbol "glWindowPos2d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos2d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos2d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glWindowPos2dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos2dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos2dv"} {:args [{:spelling "x", :type "float"} {:spelling "y", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float], :symbol "glWindowPos2f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos2f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos2f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glWindowPos2fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos2fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos2fv"} {:args [{:spelling "x", :type "int"} {:spelling "y", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glWindowPos2i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos2i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos2i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glWindowPos2iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos2iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos2iv"} {:args [{:spelling "x", :type "short"} {:spelling "y", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short], :symbol "glWindowPos2s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos2s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos2s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glWindowPos2sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos2sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos2sv"} {:args [{:spelling "x", :type "double"} {:spelling "y", :type "double"} {:spelling "z", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glWindowPos3d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos3d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos3d"} {:args [{:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/double]], :symbol "glWindowPos3dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos3dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos3dv"} {:args [{:spelling "x", :type "float"} {:spelling "y", :type "float"} {:spelling "z", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glWindowPos3f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos3f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos3f"} {:args [{:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/float]], :symbol "glWindowPos3fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos3fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos3fv"} {:args [{:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "z", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glWindowPos3i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos3i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos3i"} {:args [{:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glWindowPos3iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos3iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos3iv"} {:args [{:spelling "x", :type "short"} {:spelling "y", :type "short"} {:spelling "z", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glWindowPos3s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos3s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos3s"} {:args [{:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short]], :symbol "glWindowPos3sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glWindowPos3sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glWindowPos3sv"} {:args [{:spelling "n", :type "int"} {:spelling "ids", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGenQueries", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGenQueries, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGenQueries"} {:args [{:spelling "n", :type "int"} {:spelling "ids", :type "const unsigned int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glDeleteQueries", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDeleteQueries, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDeleteQueries"} {:args [{:spelling "id", :type "unsigned int"}], :ret {:spelling "unsigned char"}, :function/args [:coffi.mem/int], :symbol "glIsQuery", :function/ret :coffi.mem/char, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIsQuery, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIsQuery"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "id", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glBeginQuery", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glBeginQuery, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glBeginQuery"} {:args [{:spelling "target", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glEndQuery", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEndQuery, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEndQuery"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetQueryiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetQueryiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetQueryiv"} {:args [{:spelling "id", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetQueryObjectiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetQueryObjectiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetQueryObjectiv"} {:args [{:spelling "id", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetQueryObjectuiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetQueryObjectuiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetQueryObjectuiv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "buffer", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glBindBuffer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glBindBuffer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glBindBuffer"} {:args [{:spelling "n", :type "int"} {:spelling "buffers", :type "const unsigned int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glDeleteBuffers", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDeleteBuffers, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDeleteBuffers"} {:args [{:spelling "n", :type "int"} {:spelling "buffers", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGenBuffers", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGenBuffers, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGenBuffers"} {:args [{:spelling "buffer", :type "unsigned int"}], :ret {:spelling "unsigned char"}, :function/args [:coffi.mem/int], :symbol "glIsBuffer", :function/ret :coffi.mem/char, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIsBuffer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIsBuffer"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "size", :type "long"} {:spelling "data", :type "const void *"} {:spelling "usage", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/long :coffi.mem/pointer :coffi.mem/int], :symbol "glBufferData", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glBufferData, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glBufferData"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "offset", :type "long"} {:spelling "size", :type "long"} {:spelling "data", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/long :coffi.mem/long :coffi.mem/pointer], :symbol "glBufferSubData", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glBufferSubData, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glBufferSubData"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "offset", :type "long"} {:spelling "size", :type "long"} {:spelling "data", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/long :coffi.mem/long :coffi.mem/pointer], :symbol "glGetBufferSubData", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetBufferSubData, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetBufferSubData"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "access", :type "unsigned int"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glMapBuffer", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glMapBuffer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glMapBuffer"} {:args [{:spelling "target", :type "unsigned int"}], :ret {:spelling "unsigned char"}, :function/args [:coffi.mem/int], :symbol "glUnmapBuffer", :function/ret :coffi.mem/char, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUnmapBuffer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUnmapBuffer"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetBufferParameteriv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetBufferParameteriv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetBufferParameteriv"} {:args [{:spelling "target", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "void **"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/pointer]], :symbol "glGetBufferPointerv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetBufferPointerv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetBufferPointerv"} {:args [{:spelling "n", :type "int"} {:spelling "bufs", :type "const unsigned int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glDrawBuffers", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDrawBuffers, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDrawBuffers"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "x", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/double], :symbol "glVertexAttrib1d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib1d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib1d"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glVertexAttrib1dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib1dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib1dv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "x", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float], :symbol "glVertexAttrib1f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib1f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib1f"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glVertexAttrib1fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib1fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib1fv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "x", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/short], :symbol "glVertexAttrib1s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib1s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib1s"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/short]], :symbol "glVertexAttrib1sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib1sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib1sv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "x", :type "double"} {:spelling "y", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/double :coffi.mem/double], :symbol "glVertexAttrib2d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib2d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib2d"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glVertexAttrib2dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib2dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib2dv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "x", :type "float"} {:spelling "y", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float :coffi.mem/float], :symbol "glVertexAttrib2f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib2f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib2f"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glVertexAttrib2fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib2fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib2fv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "x", :type "short"} {:spelling "y", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/short :coffi.mem/short], :symbol "glVertexAttrib2s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib2s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib2s"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/short]], :symbol "glVertexAttrib2sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib2sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib2sv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "x", :type "double"} {:spelling "y", :type "double"} {:spelling "z", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glVertexAttrib3d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib3d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib3d"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glVertexAttrib3dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib3dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib3dv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "x", :type "float"} {:spelling "y", :type "float"} {:spelling "z", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glVertexAttrib3f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib3f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib3f"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glVertexAttrib3fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib3fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib3fv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "x", :type "short"} {:spelling "y", :type "short"} {:spelling "z", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glVertexAttrib3s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib3s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib3s"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/short]], :symbol "glVertexAttrib3sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib3sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib3sv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const signed char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]], :symbol "glVertexAttrib4Nbv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4Nbv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4Nbv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glVertexAttrib4Niv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4Niv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4Niv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/short]], :symbol "glVertexAttrib4Nsv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4Nsv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4Nsv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "x", :type "unsigned char"} {:spelling "y", :type "unsigned char"} {:spelling "z", :type "unsigned char"} {:spelling "w", :type "unsigned char"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/char :coffi.mem/char :coffi.mem/char :coffi.mem/char], :symbol "glVertexAttrib4Nub", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4Nub, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4Nub"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const unsigned char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]], :symbol "glVertexAttrib4Nubv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4Nubv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4Nubv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const unsigned int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glVertexAttrib4Nuiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4Nuiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4Nuiv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const unsigned short *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/short]], :symbol "glVertexAttrib4Nusv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4Nusv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4Nusv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const signed char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]], :symbol "glVertexAttrib4bv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4bv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4bv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "x", :type "double"} {:spelling "y", :type "double"} {:spelling "z", :type "double"} {:spelling "w", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double], :symbol "glVertexAttrib4d", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4d, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4d"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glVertexAttrib4dv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4dv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4dv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "x", :type "float"} {:spelling "y", :type "float"} {:spelling "z", :type "float"} {:spelling "w", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glVertexAttrib4f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4f"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glVertexAttrib4fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4fv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glVertexAttrib4iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4iv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "x", :type "short"} {:spelling "y", :type "short"} {:spelling "z", :type "short"} {:spelling "w", :type "short"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/short :coffi.mem/short :coffi.mem/short :coffi.mem/short], :symbol "glVertexAttrib4s", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4s, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4s"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const short *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/short]], :symbol "glVertexAttrib4sv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4sv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4sv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const unsigned char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]], :symbol "glVertexAttrib4ubv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4ubv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4ubv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const unsigned int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glVertexAttrib4uiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4uiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4uiv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "v", :type "const unsigned short *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/short]], :symbol "glVertexAttrib4usv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttrib4usv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttrib4usv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "size", :type "int"} {:spelling "type", :type "unsigned int"} {:spelling "normalized", :type "unsigned char"} {:spelling "stride", :type "int"} {:spelling "pointer", :type "const void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/char :coffi.mem/int :coffi.mem/pointer], :symbol "glVertexAttribPointer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glVertexAttribPointer, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glVertexAttribPointer"} {:args [{:spelling "index", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glEnableVertexAttribArray", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glEnableVertexAttribArray, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glEnableVertexAttribArray"} {:args [{:spelling "index", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glDisableVertexAttribArray", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDisableVertexAttribArray, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDisableVertexAttribArray"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "double *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "glGetVertexAttribdv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetVertexAttribdv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetVertexAttribdv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetVertexAttribfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetVertexAttribfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetVertexAttribfv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetVertexAttribiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetVertexAttribiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetVertexAttribiv"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "pointer", :type "void **"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/pointer]], :symbol "glGetVertexAttribPointerv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetVertexAttribPointerv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetVertexAttribPointerv"} {:args [{:spelling "shader", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glDeleteShader", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDeleteShader, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDeleteShader"} {:args [{:spelling "program", :type "unsigned int"} {:spelling "shader", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glDetachShader", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDetachShader, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDetachShader"} {:args [{:spelling "type", :type "unsigned int"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int], :symbol "glCreateShader", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCreateShader, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCreateShader"} {:args [{:spelling "shader", :type "unsigned int"} {:spelling "count", :type "int"} {:spelling "string", :type "const char *const *"} {:spelling "length", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/int]], :symbol "glShaderSource", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glShaderSource, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glShaderSource"} {:args [{:spelling "shader", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glCompileShader", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCompileShader, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCompileShader"} {:args [], :ret {:spelling "unsigned int"}, :function/args [], :symbol "glCreateProgram", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glCreateProgram, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glCreateProgram"} {:args [{:spelling "program", :type "unsigned int"} {:spelling "shader", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glAttachShader", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glAttachShader, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glAttachShader"} {:args [{:spelling "program", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glLinkProgram", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glLinkProgram, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glLinkProgram"} {:args [{:spelling "program", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glUseProgram", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUseProgram, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUseProgram"} {:args [{:spelling "program", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glDeleteProgram", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glDeleteProgram, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glDeleteProgram"} {:args [{:spelling "program", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glValidateProgram", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glValidateProgram, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glValidateProgram"} {:args [{:spelling "location", :type "int"} {:spelling "v0", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float], :symbol "glUniform1f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform1f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform1f"} {:args [{:spelling "location", :type "int"} {:spelling "v0", :type "float"} {:spelling "v1", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float :coffi.mem/float], :symbol "glUniform2f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform2f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform2f"} {:args [{:spelling "location", :type "int"} {:spelling "v0", :type "float"} {:spelling "v1", :type "float"} {:spelling "v2", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glUniform3f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform3f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform3f"} {:args [{:spelling "location", :type "int"} {:spelling "v0", :type "float"} {:spelling "v1", :type "float"} {:spelling "v2", :type "float"} {:spelling "v3", :type "float"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float], :symbol "glUniform4f", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform4f, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform4f"} {:args [{:spelling "location", :type "int"} {:spelling "v0", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glUniform1i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform1i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform1i"} {:args [{:spelling "location", :type "int"} {:spelling "v0", :type "int"} {:spelling "v1", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glUniform2i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform2i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform2i"} {:args [{:spelling "location", :type "int"} {:spelling "v0", :type "int"} {:spelling "v1", :type "int"} {:spelling "v2", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glUniform3i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform3i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform3i"} {:args [{:spelling "location", :type "int"} {:spelling "v0", :type "int"} {:spelling "v1", :type "int"} {:spelling "v2", :type "int"} {:spelling "v3", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glUniform4i", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform4i, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform4i"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "value", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glUniform1fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform1fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform1fv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "value", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glUniform2fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform2fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform2fv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "value", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glUniform3fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform3fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform3fv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "value", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glUniform4fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform4fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform4fv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "value", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glUniform1iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform1iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform1iv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "value", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glUniform2iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform2iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform2iv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "value", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glUniform3iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform3iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform3iv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "value", :type "const int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glUniform4iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniform4iv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniform4iv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "transpose", :type "unsigned char"} {:spelling "value", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/char [:coffi.mem/pointer :coffi.mem/float]], :symbol "glUniformMatrix2fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniformMatrix2fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniformMatrix2fv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "transpose", :type "unsigned char"} {:spelling "value", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/char [:coffi.mem/pointer :coffi.mem/float]], :symbol "glUniformMatrix3fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniformMatrix3fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniformMatrix3fv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "transpose", :type "unsigned char"} {:spelling "value", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/char [:coffi.mem/pointer :coffi.mem/float]], :symbol "glUniformMatrix4fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniformMatrix4fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniformMatrix4fv"} {:args [{:spelling "shader", :type "unsigned int"}], :ret {:spelling "unsigned char"}, :function/args [:coffi.mem/int], :symbol "glIsShader", :function/ret :coffi.mem/char, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIsShader, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIsShader"} {:args [{:spelling "program", :type "unsigned int"}], :ret {:spelling "unsigned char"}, :function/args [:coffi.mem/int], :symbol "glIsProgram", :function/ret :coffi.mem/char, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glIsProgram, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glIsProgram"} {:args [{:spelling "shader", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetShaderiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetShaderiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetShaderiv"} {:args [{:spelling "program", :type "unsigned int"} {:spelling "pname", :type "unsigned int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetProgramiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetProgramiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetProgramiv"} {:args [{:spelling "program", :type "unsigned int"} {:spelling "maxCount", :type "int"} {:spelling "count", :type "int *"} {:spelling "shaders", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetAttachedShaders", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetAttachedShaders, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetAttachedShaders"} {:args [{:spelling "shader", :type "unsigned int"} {:spelling "bufSize", :type "int"} {:spelling "length", :type "int *"} {:spelling "infoLog", :type "char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char]], :symbol "glGetShaderInfoLog", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetShaderInfoLog, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetShaderInfoLog"} {:args [{:spelling "program", :type "unsigned int"} {:spelling "bufSize", :type "int"} {:spelling "length", :type "int *"} {:spelling "infoLog", :type "char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char]], :symbol "glGetProgramInfoLog", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetProgramInfoLog, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetProgramInfoLog"} {:args [{:spelling "program", :type "unsigned int"} {:spelling "name", :type "const char *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]], :symbol "glGetUniformLocation", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetUniformLocation, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetUniformLocation"} {:args [{:spelling "program", :type "unsigned int"} {:spelling "index", :type "unsigned int"} {:spelling "bufSize", :type "int"} {:spelling "length", :type "int *"} {:spelling "size", :type "int *"} {:spelling "type", :type "unsigned int *"} {:spelling "name", :type "char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char]], :symbol "glGetActiveUniform", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetActiveUniform, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetActiveUniform"} {:args [{:spelling "program", :type "unsigned int"} {:spelling "location", :type "int"} {:spelling "params", :type "float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/float]], :symbol "glGetUniformfv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetUniformfv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetUniformfv"} {:args [{:spelling "program", :type "unsigned int"} {:spelling "location", :type "int"} {:spelling "params", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glGetUniformiv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetUniformiv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetUniformiv"} {:args [{:spelling "shader", :type "unsigned int"} {:spelling "bufSize", :type "int"} {:spelling "length", :type "int *"} {:spelling "source", :type "char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char]], :symbol "glGetShaderSource", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetShaderSource, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetShaderSource"} {:args [{:spelling "program", :type "unsigned int"} {:spelling "index", :type "unsigned int"} {:spelling "name", :type "const char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]], :symbol "glBindAttribLocation", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glBindAttribLocation, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glBindAttribLocation"} {:args [{:spelling "program", :type "unsigned int"} {:spelling "index", :type "unsigned int"} {:spelling "bufSize", :type "int"} {:spelling "length", :type "int *"} {:spelling "size", :type "int *"} {:spelling "type", :type "unsigned int *"} {:spelling "name", :type "char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char]], :symbol "glGetActiveAttrib", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetActiveAttrib, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetActiveAttrib"} {:args [{:spelling "program", :type "unsigned int"} {:spelling "name", :type "const char *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]], :symbol "glGetAttribLocation", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glGetAttribLocation, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glGetAttribLocation"} {:args [{:spelling "face", :type "unsigned int"} {:spelling "func", :type "unsigned int"} {:spelling "ref", :type "int"} {:spelling "mask", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glStencilFuncSeparate", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glStencilFuncSeparate, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glStencilFuncSeparate"} {:args [{:spelling "face", :type "unsigned int"} {:spelling "fail", :type "unsigned int"} {:spelling "zfail", :type "unsigned int"} {:spelling "zpass", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glStencilOpSeparate", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glStencilOpSeparate, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glStencilOpSeparate"} {:args [{:spelling "face", :type "unsigned int"} {:spelling "mask", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glStencilMaskSeparate", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glStencilMaskSeparate, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glStencilMaskSeparate"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "transpose", :type "unsigned char"} {:spelling "value", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/char [:coffi.mem/pointer :coffi.mem/float]], :symbol "glUniformMatrix2x3fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniformMatrix2x3fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniformMatrix2x3fv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "transpose", :type "unsigned char"} {:spelling "value", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/char [:coffi.mem/pointer :coffi.mem/float]], :symbol "glUniformMatrix3x2fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniformMatrix3x2fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniformMatrix3x2fv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "transpose", :type "unsigned char"} {:spelling "value", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/char [:coffi.mem/pointer :coffi.mem/float]], :symbol "glUniformMatrix2x4fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniformMatrix2x4fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniformMatrix2x4fv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "transpose", :type "unsigned char"} {:spelling "value", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/char [:coffi.mem/pointer :coffi.mem/float]], :symbol "glUniformMatrix4x2fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniformMatrix4x2fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniformMatrix4x2fv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "transpose", :type "unsigned char"} {:spelling "value", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/char [:coffi.mem/pointer :coffi.mem/float]], :symbol "glUniformMatrix3x4fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniformMatrix3x4fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniformMatrix3x4fv"} {:args [{:spelling "location", :type "int"} {:spelling "count", :type "int"} {:spelling "transpose", :type "unsigned char"} {:spelling "value", :type "const float *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/char [:coffi.mem/pointer :coffi.mem/float]], :symbol "glUniformMatrix4x3fv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glUniformMatrix4x3fv, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "glUniformMatrix4x3fv"} {:args [], :ret {:spelling "int"}, :function/args [], :symbol "glfwInit", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwInit, :raw-comment "/*! @brief Initializes the GLFW library.\n *\n *  This function initializes the GLFW library.  Before most GLFW functions can\n *  be used, GLFW must be initialized, and before an application terminates GLFW\n *  should be terminated in order to free any resources allocated during or\n *  after initialization.\n *\n *  If this function fails, it calls @ref glfwTerminate before returning.  If it\n *  succeeds, you should call @ref glfwTerminate before the application exits.\n *\n *  Additional calls to this function after successful initialization but before\n *  termination will return `GLFW_TRUE` immediately.\n *\n *  @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark @macos This function will change the current directory of the\n *  application to the `Contents/Resources` subdirectory of the application's\n *  bundle, if present.  This can be disabled with the @ref\n *  GLFW_COCOA_CHDIR_RESOURCES init hint.\n *\n *  @remark @x11 This function will set the `LC_CTYPE` category of the\n *  application locale according to the current environment if that category is\n *  still \"C\".  This is because the \"C\" locale breaks Unicode text input.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref intro_init\n *  @sa @ref glfwTerminate\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup init\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwInit"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glfwTerminate", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwTerminate, :raw-comment "/*! @brief Terminates the GLFW library.\n *\n *  This function destroys all remaining windows and cursors, restores any\n *  modified gamma ramps and frees any other allocated resources.  Once this\n *  function is called, you must again call @ref glfwInit successfully before\n *  you will be able to use most GLFW functions.\n *\n *  If GLFW has been successfully initialized, this function should be called\n *  before the application exits.  If initialization fails, there is no need to\n *  call this function, as it is called by @ref glfwInit before it returns\n *  failure.\n *\n *  This function has no effect if GLFW is not initialized.\n *\n *  @errors Possible errors include @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark This function may be called before @ref glfwInit.\n *\n *  @warning The contexts of any remaining windows must not be current on any\n *  other thread when this function is called.\n *\n *  @reentrancy This function must not be called from a callback.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref intro_init\n *  @sa @ref glfwInit\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup init\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwTerminate"} {:args [{:spelling "hint", :type "int"} {:spelling "value", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glfwInitHint", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwInitHint, :raw-comment "/*! @brief Sets the specified init hint to the desired value.\n *\n *  This function sets hints for the next initialization of GLFW.\n *\n *  The values you set hints to are never reset by GLFW, but they only take\n *  effect during initialization.  Once GLFW has been initialized, any values\n *  you set will be ignored until the library is terminated and initialized\n *  again.\n *\n *  Some hints are platform specific.  These may be set on any platform but they\n *  will only affect their specific platform.  Other platforms will ignore them.\n *  Setting these hints requires no platform specific headers or functions.\n *\n *  @param[in] hint The [init hint](@ref init_hints) to set.\n *  @param[in] value The new value of the init hint.\n *\n *  @errors Possible errors include @ref GLFW_INVALID_ENUM and @ref\n *  GLFW_INVALID_VALUE.\n *\n *  @remarks This function may be called before @ref glfwInit.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa init_hints\n *  @sa glfwInit\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup init\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwInitHint"} {:args [{:spelling "major", :type "int *"} {:spelling "minor", :type "int *"} {:spelling "rev", :type "int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "glfwGetVersion", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetVersion, :raw-comment "/*! @brief Retrieves the version of the GLFW library.\n *\n *  This function retrieves the major, minor and revision numbers of the GLFW\n *  library.  It is intended for when you are using GLFW as a shared library and\n *  want to ensure that you are using the minimum required version.\n *\n *  Any or all of the version arguments may be `NULL`.\n *\n *  @param[out] major Where to store the major version number, or `NULL`.\n *  @param[out] minor Where to store the minor version number, or `NULL`.\n *  @param[out] rev Where to store the revision number, or `NULL`.\n *\n *  @errors None.\n *\n *  @remark This function may be called before @ref glfwInit.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref intro_version\n *  @sa @ref glfwGetVersionString\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup init\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetVersion"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "glfwGetVersionString", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetVersionString, :raw-comment "/*! @brief Returns a string describing the compile-time configuration.\n *\n *  This function returns the compile-time generated\n *  [version string](@ref intro_version_string) of the GLFW library binary.  It\n *  describes the version, platform, compiler and any platform-specific\n *  compile-time options.  It should not be confused with the OpenGL or OpenGL\n *  ES version string, queried with `glGetString`.\n *\n *  __Do not use the version string__ to parse the GLFW library version.  The\n *  @ref glfwGetVersion function provides the version of the running library\n *  binary in numerical format.\n *\n *  @return The ASCII encoded GLFW version string.\n *\n *  @errors None.\n *\n *  @remark This function may be called before @ref glfwInit.\n *\n *  @pointer_lifetime The returned string is static and compile-time generated.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref intro_version\n *  @sa @ref glfwGetVersion\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup init\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetVersionString"} {:args [{:spelling "description", :type "const char **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "glfwGetError", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetError, :raw-comment "/*! @brief Returns and clears the last error for the calling thread.\n *\n *  This function returns and clears the [error code](@ref errors) of the last\n *  error that occurred on the calling thread, and optionally a UTF-8 encoded\n *  human-readable description of it.  If no error has occurred since the last\n *  call, it returns @ref GLFW_NO_ERROR (zero) and the description pointer is\n *  set to `NULL`.\n *\n *  @param[in] description Where to store the error description pointer, or `NULL`.\n *  @return The last error code for the calling thread, or @ref GLFW_NO_ERROR\n *  (zero).\n *\n *  @errors None.\n *\n *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is guaranteed to be valid only until the\n *  next error occurs or the library is terminated.\n *\n *  @remark This function may be called before @ref glfwInit.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref error_handling\n *  @sa @ref glfwSetErrorCallback\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup init\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetError"} {:args [{:spelling "callback", :type "void (*)(int, const char *)"}], :ret {:spelling "void (*)(int, const char *)"}, :function/args [[:coffi.ffi/fn [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/void]], :symbol "glfwSetErrorCallback", :function/ret [:coffi.ffi/fn [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetErrorCallback, :raw-comment "/*! @brief Sets the error callback.\n *\n *  This function sets the error callback, which is called with an error code\n *  and a human-readable description each time a GLFW error occurs.\n *\n *  The error code is set before the callback is called.  Calling @ref\n *  glfwGetError from the error callback will return the same value as the error\n *  code argument.\n *\n *  The error callback is called on the thread where the error occurred.  If you\n *  are using GLFW from multiple threads, your error callback needs to be\n *  written accordingly.\n *\n *  Because the description string may have been generated specifically for that\n *  error, it is not guaranteed to be valid after the callback has returned.  If\n *  you wish to use it after the callback returns, you need to make a copy.\n *\n *  Once set, the error callback remains set even after the library has been\n *  terminated.\n *\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set.\n *\n *  @callback_signature\n *  @code\n *  void callback_name(int error_code, const char* description)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [callback pointer type](@ref GLFWerrorfun).\n *\n *  @errors None.\n *\n *  @remark This function may be called before @ref glfwInit.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref error_handling\n *  @sa @ref glfwGetError\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup init\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetErrorCallback"} {:args [{:spelling "count", :type "int *"}], :ret {:spelling "struct GLFWmonitor **"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glfwGetMonitors", :function/ret [:coffi.mem/pointer [:coffi.mem/pointer :clong/GLFWmonitor]], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetMonitors, :raw-comment "/*! @brief Returns the currently connected monitors.\n *\n *  This function returns an array of handles for all currently connected\n *  monitors.  The primary monitor is always first in the returned array.  If no\n *  monitors were found, this function returns `NULL`.\n *\n *  @param[out] count Where to store the number of monitors in the returned\n *  array.  This is set to zero if an error occurred.\n *  @return An array of monitor handles, or `NULL` if no monitors were found or\n *  if an [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is guaranteed to be valid only until the\n *  monitor configuration changes or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_monitors\n *  @sa @ref monitor_event\n *  @sa @ref glfwGetPrimaryMonitor\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetMonitors"} {:args [], :ret {:spelling "struct GLFWmonitor *"}, :function/args [], :symbol "glfwGetPrimaryMonitor", :function/ret [:coffi.mem/pointer :clong/GLFWmonitor], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetPrimaryMonitor, :raw-comment "/*! @brief Returns the primary monitor.\n *\n *  This function returns the primary monitor.  This is usually the monitor\n *  where elements like the task bar or global menu bar are located.\n *\n *  @return The primary monitor, or `NULL` if no monitors were found or if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @remark The primary monitor is always first in the array returned by @ref\n *  glfwGetMonitors.\n *\n *  @sa @ref monitor_monitors\n *  @sa @ref glfwGetMonitors\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetPrimaryMonitor"} {:args [{:spelling "monitor", :type "struct GLFWmonitor *"} {:spelling "xpos", :type "int *"} {:spelling "ypos", :type "int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWmonitor] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "glfwGetMonitorPos", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetMonitorPos, :raw-comment "/*! @brief Returns the position of the monitor's viewport on the virtual screen.\n *\n *  This function returns the position, in screen coordinates, of the upper-left\n *  corner of the specified monitor.\n *\n *  Any or all of the position arguments may be `NULL`.  If an error occurs, all\n *  non-`NULL` position arguments will be set to zero.\n *\n *  @param[in] monitor The monitor to query.\n *  @param[out] xpos Where to store the monitor x-coordinate, or `NULL`.\n *  @param[out] ypos Where to store the monitor y-coordinate, or `NULL`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_properties\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetMonitorPos"} {:args [{:spelling "monitor", :type "struct GLFWmonitor *"} {:spelling "xpos", :type "int *"} {:spelling "ypos", :type "int *"} {:spelling "width", :type "int *"} {:spelling "height", :type "int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWmonitor] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "glfwGetMonitorWorkarea", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetMonitorWorkarea, :raw-comment "/*! @brief Retrieves the work area of the monitor.\n *\n *  This function returns the position, in screen coordinates, of the upper-left\n *  corner of the work area of the specified monitor along with the work area\n *  size in screen coordinates. The work area is defined as the area of the\n *  monitor not occluded by the operating system task bar where present. If no\n *  task bar exists then the work area is the monitor resolution in screen\n *  coordinates.\n *\n *  Any or all of the position and size arguments may be `NULL`.  If an error\n *  occurs, all non-`NULL` position and size arguments will be set to zero.\n *\n *  @param[in] monitor The monitor to query.\n *  @param[out] xpos Where to store the monitor x-coordinate, or `NULL`.\n *  @param[out] ypos Where to store the monitor y-coordinate, or `NULL`.\n *  @param[out] width Where to store the monitor width, or `NULL`.\n *  @param[out] height Where to store the monitor height, or `NULL`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_workarea\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetMonitorWorkarea"} {:args [{:spelling "monitor", :type "struct GLFWmonitor *"} {:spelling "widthMM", :type "int *"} {:spelling "heightMM", :type "int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWmonitor] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "glfwGetMonitorPhysicalSize", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetMonitorPhysicalSize, :raw-comment "/*! @brief Returns the physical size of the monitor.\n *\n *  This function returns the size, in millimetres, of the display area of the\n *  specified monitor.\n *\n *  Some systems do not provide accurate monitor size information, either\n *  because the monitor\n *  [EDID](https://en.wikipedia.org/wiki/Extended_display_identification_data)\n *  data is incorrect or because the driver does not report it accurately.\n *\n *  Any or all of the size arguments may be `NULL`.  If an error occurs, all\n *  non-`NULL` size arguments will be set to zero.\n *\n *  @param[in] monitor The monitor to query.\n *  @param[out] widthMM Where to store the width, in millimetres, of the\n *  monitor's display area, or `NULL`.\n *  @param[out] heightMM Where to store the height, in millimetres, of the\n *  monitor's display area, or `NULL`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @remark @win32 On Windows 8 and earlier the physical size is calculated from\n *  the current resolution and system DPI instead of querying the monitor EDID data.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_properties\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetMonitorPhysicalSize"} {:args [{:spelling "monitor", :type "struct GLFWmonitor *"} {:spelling "xscale", :type "float *"} {:spelling "yscale", :type "float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWmonitor] [:coffi.mem/pointer :coffi.mem/float] [:coffi.mem/pointer :coffi.mem/float]], :symbol "glfwGetMonitorContentScale", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetMonitorContentScale, :raw-comment "/*! @brief Retrieves the content scale for the specified monitor.\n *\n *  This function retrieves the content scale for the specified monitor.  The\n *  content scale is the ratio between the current DPI and the platform's\n *  default DPI.  This is especially important for text and any UI elements.  If\n *  the pixel dimensions of your UI scaled by this look appropriate on your\n *  machine then it should appear at a reasonable size on other machines\n *  regardless of their DPI and scaling settings.  This relies on the system DPI\n *  and scaling settings being somewhat correct.\n *\n *  The content scale may depend on both the monitor resolution and pixel\n *  density and on user settings.  It may be very different from the raw DPI\n *  calculated from the physical size and current resolution.\n *\n *  @param[in] monitor The monitor to query.\n *  @param[out] xscale Where to store the x-axis content scale, or `NULL`.\n *  @param[out] yscale Where to store the y-axis content scale, or `NULL`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_scale\n *  @sa @ref glfwGetWindowContentScale\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetMonitorContentScale"} {:args [{:spelling "monitor", :type "struct GLFWmonitor *"}], :ret {:spelling "const char *"}, :function/args [[:coffi.mem/pointer :clong/GLFWmonitor]], :symbol "glfwGetMonitorName", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetMonitorName, :raw-comment "/*! @brief Returns the name of the specified monitor.\n *\n *  This function returns a human-readable name, encoded as UTF-8, of the\n *  specified monitor.  The name typically reflects the make and model of the\n *  monitor and is not guaranteed to be unique among the connected monitors.\n *\n *  @param[in] monitor The monitor to query.\n *  @return The UTF-8 encoded name of the monitor, or `NULL` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified monitor is\n *  disconnected or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_properties\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetMonitorName"} {:args [{:spelling "monitor", :type "struct GLFWmonitor *"} {:spelling "pointer", :type "void *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWmonitor] :coffi.mem/pointer], :symbol "glfwSetMonitorUserPointer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetMonitorUserPointer, :raw-comment "/*! @brief Sets the user pointer of the specified monitor.\n *\n *  This function sets the user-defined pointer of the specified monitor.  The\n *  current value is retained until the monitor is disconnected.  The initial\n *  value is `NULL`.\n *\n *  This function may be called from the monitor callback, even for a monitor\n *  that is being disconnected.\n *\n *  @param[in] monitor The monitor whose pointer to set.\n *  @param[in] pointer The new value.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref monitor_userptr\n *  @sa @ref glfwGetMonitorUserPointer\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetMonitorUserPointer"} {:args [{:spelling "monitor", :type "struct GLFWmonitor *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clong/GLFWmonitor]], :symbol "glfwGetMonitorUserPointer", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetMonitorUserPointer, :raw-comment "/*! @brief Returns the user pointer of the specified monitor.\n *\n *  This function returns the current value of the user-defined pointer of the\n *  specified monitor.  The initial value is `NULL`.\n *\n *  This function may be called from the monitor callback, even for a monitor\n *  that is being disconnected.\n *\n *  @param[in] monitor The monitor whose pointer to return.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref monitor_userptr\n *  @sa @ref glfwSetMonitorUserPointer\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetMonitorUserPointer"} {:args [{:spelling "callback", :type "void (*)(struct GLFWmonitor *, int)"}], :ret {:spelling "void (*)(struct GLFWmonitor *, int)"}, :function/args [[:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWmonitor] :coffi.mem/int] :coffi.mem/void]], :symbol "glfwSetMonitorCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWmonitor] :coffi.mem/int] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetMonitorCallback, :raw-comment "/*! @brief Sets the monitor configuration callback.\n *\n *  This function sets the monitor configuration callback, or removes the\n *  currently set callback.  This is called when a monitor is connected to or\n *  disconnected from the system.\n *\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWmonitor* monitor, int event)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWmonitorfun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_event\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetMonitorCallback"} {:args [{:spelling "monitor", :type "struct GLFWmonitor *"} {:spelling "count", :type "int *"}], :ret {:spelling "const struct GLFWvidmode *"}, :function/args [[:coffi.mem/pointer :clong/GLFWmonitor] [:coffi.mem/pointer :coffi.mem/int]], :symbol "glfwGetVideoModes", :function/ret [:coffi.mem/pointer :clong/GLFWvidmode], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetVideoModes, :raw-comment "/*! @brief Returns the available video modes for the specified monitor.\n *\n *  This function returns an array of all video modes supported by the specified\n *  monitor.  The returned array is sorted in ascending order, first by color\n *  bit depth (the sum of all channel depths), then by resolution area (the\n *  product of width and height), then resolution width and finally by refresh\n *  rate.\n *\n *  @param[in] monitor The monitor to query.\n *  @param[out] count Where to store the number of video modes in the returned\n *  array.  This is set to zero if an error occurred.\n *  @return An array of video modes, or `NULL` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified monitor is\n *  disconnected, this function is called again for that monitor or the library\n *  is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_modes\n *  @sa @ref glfwGetVideoMode\n *\n *  @since Added in version 1.0.\n *  @glfw3 Changed to return an array of modes for a specific monitor.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetVideoModes"} {:args [{:spelling "monitor", :type "struct GLFWmonitor *"}], :ret {:spelling "const struct GLFWvidmode *"}, :function/args [[:coffi.mem/pointer :clong/GLFWmonitor]], :symbol "glfwGetVideoMode", :function/ret [:coffi.mem/pointer :clong/GLFWvidmode], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetVideoMode, :raw-comment "/*! @brief Returns the current mode of the specified monitor.\n *\n *  This function returns the current video mode of the specified monitor.  If\n *  you have created a full screen window for that monitor, the return value\n *  will depend on whether that window is iconified.\n *\n *  @param[in] monitor The monitor to query.\n *  @return The current mode of the monitor, or `NULL` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified monitor is\n *  disconnected or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_modes\n *  @sa @ref glfwGetVideoModes\n *\n *  @since Added in version 3.0.  Replaces `glfwGetDesktopMode`.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetVideoMode"} {:args [{:spelling "monitor", :type "struct GLFWmonitor *"} {:spelling "gamma", :type "float"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWmonitor] :coffi.mem/float], :symbol "glfwSetGamma", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetGamma, :raw-comment "/*! @brief Generates a gamma ramp and sets it for the specified monitor.\n *\n *  This function generates an appropriately sized gamma ramp from the specified\n *  exponent and then calls @ref glfwSetGammaRamp with it.  The value must be\n *  a finite number greater than zero.\n *\n *  The software controlled gamma ramp is applied _in addition_ to the hardware\n *  gamma correction, which today is usually an approximation of sRGB gamma.\n *  This means that setting a perfectly linear ramp, or gamma 1.0, will produce\n *  the default (usually sRGB-like) behavior.\n *\n *  For gamma correct rendering with OpenGL or OpenGL ES, see the @ref\n *  GLFW_SRGB_CAPABLE hint.\n *\n *  @param[in] monitor The monitor whose gamma ramp to set.\n *  @param[in] gamma The desired exponent.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark @wayland Gamma handling is a privileged protocol, this function\n *  will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_gamma\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetGamma"} {:args [{:spelling "monitor", :type "struct GLFWmonitor *"}], :ret {:spelling "const struct GLFWgammaramp *"}, :function/args [[:coffi.mem/pointer :clong/GLFWmonitor]], :symbol "glfwGetGammaRamp", :function/ret [:coffi.mem/pointer :clong/GLFWgammaramp], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetGammaRamp, :raw-comment "/*! @brief Returns the current gamma ramp for the specified monitor.\n *\n *  This function returns the current gamma ramp of the specified monitor.\n *\n *  @param[in] monitor The monitor to query.\n *  @return The current gamma ramp, or `NULL` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @wayland Gamma handling is a privileged protocol, this function\n *  will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR while\n *  returning `NULL`.\n *\n *  @pointer_lifetime The returned structure and its arrays are allocated and\n *  freed by GLFW.  You should not free them yourself.  They are valid until the\n *  specified monitor is disconnected, this function is called again for that\n *  monitor or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_gamma\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetGammaRamp"} {:args [{:spelling "monitor", :type "struct GLFWmonitor *"} {:spelling "ramp", :type "const struct GLFWgammaramp *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWmonitor] [:coffi.mem/pointer :clong/GLFWgammaramp]], :symbol "glfwSetGammaRamp", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetGammaRamp, :raw-comment "/*! @brief Sets the current gamma ramp for the specified monitor.\n *\n *  This function sets the current gamma ramp for the specified monitor.  The\n *  original gamma ramp for that monitor is saved by GLFW the first time this\n *  function is called and is restored by @ref glfwTerminate.\n *\n *  The software controlled gamma ramp is applied _in addition_ to the hardware\n *  gamma correction, which today is usually an approximation of sRGB gamma.\n *  This means that setting a perfectly linear ramp, or gamma 1.0, will produce\n *  the default (usually sRGB-like) behavior.\n *\n *  For gamma correct rendering with OpenGL or OpenGL ES, see the @ref\n *  GLFW_SRGB_CAPABLE hint.\n *\n *  @param[in] monitor The monitor whose gamma ramp to set.\n *  @param[in] ramp The gamma ramp to use.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark The size of the specified gamma ramp should match the size of the\n *  current ramp for that monitor.\n *\n *  @remark @win32 The gamma ramp size must be 256.\n *\n *  @remark @wayland Gamma handling is a privileged protocol, this function\n *  will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The specified gamma ramp is copied before this function\n *  returns.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_gamma\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetGammaRamp"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glfwDefaultWindowHints", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwDefaultWindowHints, :raw-comment "/*! @brief Resets all window hints to their default values.\n *\n *  This function resets all window hints to their\n *  [default values](@ref window_hints_values).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_hints\n *  @sa @ref glfwWindowHint\n *  @sa @ref glfwWindowHintString\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwDefaultWindowHints"} {:args [{:spelling "hint", :type "int"} {:spelling "value", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glfwWindowHint", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwWindowHint, :raw-comment "/*! @brief Sets the specified window hint to the desired value.\n *\n *  This function sets hints for the next call to @ref glfwCreateWindow.  The\n *  hints, once set, retain their values until changed by a call to this\n *  function or @ref glfwDefaultWindowHints, or until the library is terminated.\n *\n *  Only integer value hints can be set with this function.  String value hints\n *  are set with @ref glfwWindowHintString.\n *\n *  This function does not check whether the specified hint values are valid.\n *  If you set hints to invalid values this will instead be reported by the next\n *  call to @ref glfwCreateWindow.\n *\n *  Some hints are platform specific.  These may be set on any platform but they\n *  will only affect their specific platform.  Other platforms will ignore them.\n *  Setting these hints requires no platform specific headers or functions.\n *\n *  @param[in] hint The [window hint](@ref window_hints) to set.\n *  @param[in] value The new value of the window hint.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_ENUM.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_hints\n *  @sa @ref glfwWindowHintString\n *  @sa @ref glfwDefaultWindowHints\n *\n *  @since Added in version 3.0.  Replaces `glfwOpenWindowHint`.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwWindowHint"} {:args [{:spelling "hint", :type "int"} {:spelling "value", :type "const char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]], :symbol "glfwWindowHintString", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwWindowHintString, :raw-comment "/*! @brief Sets the specified window hint to the desired value.\n *\n *  This function sets hints for the next call to @ref glfwCreateWindow.  The\n *  hints, once set, retain their values until changed by a call to this\n *  function or @ref glfwDefaultWindowHints, or until the library is terminated.\n *\n *  Only string type hints can be set with this function.  Integer value hints\n *  are set with @ref glfwWindowHint.\n *\n *  This function does not check whether the specified hint values are valid.\n *  If you set hints to invalid values this will instead be reported by the next\n *  call to @ref glfwCreateWindow.\n *\n *  Some hints are platform specific.  These may be set on any platform but they\n *  will only affect their specific platform.  Other platforms will ignore them.\n *  Setting these hints requires no platform specific headers or functions.\n *\n *  @param[in] hint The [window hint](@ref window_hints) to set.\n *  @param[in] value The new value of the window hint.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_ENUM.\n *\n *  @pointer_lifetime The specified string is copied before this function\n *  returns.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_hints\n *  @sa @ref glfwWindowHint\n *  @sa @ref glfwDefaultWindowHints\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwWindowHintString"} {:args [{:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "title", :type "const char *"} {:spelling "monitor", :type "struct GLFWmonitor *"} {:spelling "share", :type "struct GLFWwindow *"}], :ret {:spelling "struct GLFWwindow *"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :clong/GLFWmonitor] [:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwCreateWindow", :function/ret [:coffi.mem/pointer :clong/GLFWwindow], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwCreateWindow, :raw-comment "/*! @brief Creates a window and its associated context.\n *\n *  This function creates a window and its associated OpenGL or OpenGL ES\n *  context.  Most of the options controlling how the window and its context\n *  should be created are specified with [window hints](@ref window_hints).\n *\n *  Successful creation does not change which context is current.  Before you\n *  can use the newly created context, you need to\n *  [make it current](@ref context_current).  For information about the `share`\n *  parameter, see @ref context_sharing.\n *\n *  The created window, framebuffer and context may differ from what you\n *  requested, as not all parameters and hints are\n *  [hard constraints](@ref window_hints_hard).  This includes the size of the\n *  window, especially for full screen windows.  To query the actual attributes\n *  of the created window, framebuffer and context, see @ref\n *  glfwGetWindowAttrib, @ref glfwGetWindowSize and @ref glfwGetFramebufferSize.\n *\n *  To create a full screen window, you need to specify the monitor the window\n *  will cover.  If no monitor is specified, the window will be windowed mode.\n *  Unless you have a way for the user to choose a specific monitor, it is\n *  recommended that you pick the primary monitor.  For more information on how\n *  to query connected monitors, see @ref monitor_monitors.\n *\n *  For full screen windows, the specified size becomes the resolution of the\n *  window's _desired video mode_.  As long as a full screen window is not\n *  iconified, the supported video mode most closely matching the desired video\n *  mode is set for the specified monitor.  For more information about full\n *  screen windows, including the creation of so called _windowed full screen_\n *  or _borderless full screen_ windows, see @ref window_windowed_full_screen.\n *\n *  Once you have created the window, you can switch it between windowed and\n *  full screen mode with @ref glfwSetWindowMonitor.  This will not affect its\n *  OpenGL or OpenGL ES context.\n *\n *  By default, newly created windows use the placement recommended by the\n *  window system.  To create the window at a specific position, make it\n *  initially invisible using the [GLFW_VISIBLE](@ref GLFW_VISIBLE_hint) window\n *  hint, set its [position](@ref window_pos) and then [show](@ref window_hide)\n *  it.\n *\n *  As long as at least one full screen window is not iconified, the screensaver\n *  is prohibited from starting.\n *\n *  Window systems put limits on window sizes.  Very large or very small window\n *  dimensions may be overridden by the window system on creation.  Check the\n *  actual [size](@ref window_size) after creation.\n *\n *  The [swap interval](@ref buffer_swap) is not set during window creation and\n *  the initial value may vary depending on driver settings and defaults.\n *\n *  @param[in] width The desired width, in screen coordinates, of the window.\n *  This must be greater than zero.\n *  @param[in] height The desired height, in screen coordinates, of the window.\n *  This must be greater than zero.\n *  @param[in] title The initial, UTF-8 encoded window title.\n *  @param[in] monitor The monitor to use for full screen mode, or `NULL` for\n *  windowed mode.\n *  @param[in] share The window whose context to share resources with, or `NULL`\n *  to not share resources.\n *  @return The handle of the created window, or `NULL` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM, @ref GLFW_INVALID_VALUE, @ref GLFW_API_UNAVAILABLE, @ref\n *  GLFW_VERSION_UNAVAILABLE, @ref GLFW_FORMAT_UNAVAILABLE and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @win32 Window creation will fail if the Microsoft GDI software\n *  OpenGL implementation is the only one available.\n *\n *  @remark @win32 If the executable has an icon resource named `GLFW_ICON,` it\n *  will be set as the initial icon for the window.  If no such icon is present,\n *  the `IDI_APPLICATION` icon will be used instead.  To set a different icon,\n *  see @ref glfwSetWindowIcon.\n *\n *  @remark @win32 The context to share resources with must not be current on\n *  any other thread.\n *\n *  @remark @macos The OS only supports forward-compatible core profile contexts\n *  for OpenGL versions 3.2 and later.  Before creating an OpenGL context of\n *  version 3.2 or later you must set the\n *  [GLFW_OPENGL_FORWARD_COMPAT](@ref GLFW_OPENGL_FORWARD_COMPAT_hint) and\n *  [GLFW_OPENGL_PROFILE](@ref GLFW_OPENGL_PROFILE_hint) hints accordingly.\n *  OpenGL 3.0 and 3.1 contexts are not supported at all on macOS.\n *\n *  @remark @macos The GLFW window has no icon, as it is not a document\n *  window, but the dock icon will be the same as the application bundle's icon.\n *  For more information on bundles, see the\n *  [Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)\n *  in the Mac Developer Library.\n *\n *  @remark @macos The first time a window is created the menu bar is created.\n *  If GLFW finds a `MainMenu.nib` it is loaded and assumed to contain a menu\n *  bar.  Otherwise a minimal menu bar is created manually with common commands\n *  like Hide, Quit and About.  The About entry opens a minimal about dialog\n *  with information from the application's bundle.  Menu bar creation can be\n *  disabled entirely with the @ref GLFW_COCOA_MENUBAR init hint.\n *\n *  @remark @macos On OS X 10.10 and later the window frame will not be rendered\n *  at full resolution on Retina displays unless the\n *  [GLFW_COCOA_RETINA_FRAMEBUFFER](@ref GLFW_COCOA_RETINA_FRAMEBUFFER_hint)\n *  hint is `GLFW_TRUE` and the `NSHighResolutionCapable` key is enabled in the\n *  application bundle's `Info.plist`.  For more information, see\n *  [High Resolution Guidelines for OS X](https://developer.apple.com/library/mac/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Explained/Explained.html)\n *  in the Mac Developer Library.  The GLFW test and example programs use\n *  a custom `Info.plist` template for this, which can be found as\n *  `CMake/MacOSXBundleInfo.plist.in` in the source tree.\n *\n *  @remark @macos When activating frame autosaving with\n *  [GLFW_COCOA_FRAME_NAME](@ref GLFW_COCOA_FRAME_NAME_hint), the specified\n *  window size and position may be overridden by previously saved values.\n *\n *  @remark @x11 Some window managers will not respect the placement of\n *  initially hidden windows.\n *\n *  @remark @x11 Due to the asynchronous nature of X11, it may take a moment for\n *  a window to reach its requested state.  This means you may not be able to\n *  query the final size, position or other attributes directly after window\n *  creation.\n *\n *  @remark @x11 The class part of the `WM_CLASS` window property will by\n *  default be set to the window title passed to this function.  The instance\n *  part will use the contents of the `RESOURCE_NAME` environment variable, if\n *  present and not empty, or fall back to the window title.  Set the\n *  [GLFW_X11_CLASS_NAME](@ref GLFW_X11_CLASS_NAME_hint) and\n *  [GLFW_X11_INSTANCE_NAME](@ref GLFW_X11_INSTANCE_NAME_hint) window hints to\n *  override this.\n *\n *  @remark @wayland Compositors should implement the xdg-decoration protocol\n *  for GLFW to decorate the window properly.  If this protocol isn't\n *  supported, or if the compositor prefers client-side decorations, a very\n *  simple fallback frame will be drawn using the wp_viewporter protocol.  A\n *  compositor can still emit close, maximize or fullscreen events, using for\n *  instance a keybind mechanism.  If neither of these protocols is supported,\n *  the window won't be decorated.\n *\n *  @remark @wayland A full screen window will not attempt to change the mode,\n *  no matter what the requested size or refresh rate.\n *\n *  @remark @wayland Screensaver inhibition requires the idle-inhibit protocol\n *  to be implemented in the user's compositor.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_creation\n *  @sa @ref glfwDestroyWindow\n *\n *  @since Added in version 3.0.  Replaces `glfwOpenWindow`.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwCreateWindow"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwDestroyWindow", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwDestroyWindow, :raw-comment "/*! @brief Destroys the specified window and its context.\n *\n *  This function destroys the specified window and its context.  On calling\n *  this function, no further callbacks will be called for that window.\n *\n *  If the context of the specified window is current on the main thread, it is\n *  detached before being destroyed.\n *\n *  @param[in] window The window to destroy.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @note The context of the specified window must not be current on any other\n *  thread when this function is called.\n *\n *  @reentrancy This function must not be called from a callback.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_creation\n *  @sa @ref glfwCreateWindow\n *\n *  @since Added in version 3.0.  Replaces `glfwCloseWindow`.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwDestroyWindow"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwWindowShouldClose", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwWindowShouldClose, :raw-comment "/*! @brief Checks the close flag of the specified window.\n *\n *  This function returns the value of the close flag of the specified window.\n *\n *  @param[in] window The window to query.\n *  @return The value of the close flag.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref window_close\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwWindowShouldClose"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "value", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int], :symbol "glfwSetWindowShouldClose", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowShouldClose, :raw-comment "/*! @brief Sets the close flag of the specified window.\n *\n *  This function sets the value of the close flag of the specified window.\n *  This can be used to override the user's attempt to close the window, or\n *  to signal that it should be closed.\n *\n *  @param[in] window The window whose flag to change.\n *  @param[in] value The new value.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref window_close\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowShouldClose"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "title", :type "const char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.mem/pointer :coffi.mem/char]], :symbol "glfwSetWindowTitle", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowTitle, :raw-comment "/*! @brief Sets the title of the specified window.\n *\n *  This function sets the window title, encoded as UTF-8, of the specified\n *  window.\n *\n *  @param[in] window The window whose title to change.\n *  @param[in] title The UTF-8 encoded window title.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @macos The window title will not be updated until the next time you\n *  process events.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_title\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowTitle"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "count", :type "int"} {:spelling "images", :type "const struct GLFWimage *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int [:coffi.mem/pointer :clong/GLFWimage]], :symbol "glfwSetWindowIcon", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowIcon, :raw-comment "/*! @brief Sets the icon for the specified window.\n *\n *  This function sets the icon of the specified window.  If passed an array of\n *  candidate images, those of or closest to the sizes desired by the system are\n *  selected.  If no images are specified, the window reverts to its default\n *  icon.\n *\n *  The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight\n *  bits per channel with the red channel first.  They are arranged canonically\n *  as packed sequential rows, starting from the top-left corner.\n *\n *  The desired image sizes varies depending on platform and system settings.\n *  The selected images will be rescaled as needed.  Good sizes include 16x16,\n *  32x32 and 48x48.\n *\n *  @param[in] window The window whose icon to set.\n *  @param[in] count The number of images in the specified array, or zero to\n *  revert to the default window icon.\n *  @param[in] images The images to create the icon from.  This is ignored if\n *  count is zero.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The specified image data is copied before this function\n *  returns.\n *\n *  @remark @macos The GLFW window has no icon, as it is not a document\n *  window, so this function does nothing.  The dock icon will be the same as\n *  the application bundle's icon.  For more information on bundles, see the\n *  [Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)\n *  in the Mac Developer Library.\n *\n *  @remark @wayland There is no existing protocol to change an icon, the\n *  window will thus inherit the one defined in the application's desktop file.\n *  This function always emits @ref GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_icon\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowIcon"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "xpos", :type "int *"} {:spelling "ypos", :type "int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "glfwGetWindowPos", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetWindowPos, :raw-comment "/*! @brief Retrieves the position of the content area of the specified window.\n *\n *  This function retrieves the position, in screen coordinates, of the\n *  upper-left corner of the content area of the specified window.\n *\n *  Any or all of the position arguments may be `NULL`.  If an error occurs, all\n *  non-`NULL` position arguments will be set to zero.\n *\n *  @param[in] window The window to query.\n *  @param[out] xpos Where to store the x-coordinate of the upper-left corner of\n *  the content area, or `NULL`.\n *  @param[out] ypos Where to store the y-coordinate of the upper-left corner of\n *  the content area, or `NULL`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @wayland There is no way for an application to retrieve the global\n *  position of its windows, this function will always emit @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_pos\n *  @sa @ref glfwSetWindowPos\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetWindowPos"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "xpos", :type "int"} {:spelling "ypos", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int], :symbol "glfwSetWindowPos", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowPos, :raw-comment "/*! @brief Sets the position of the content area of the specified window.\n *\n *  This function sets the position, in screen coordinates, of the upper-left\n *  corner of the content area of the specified windowed mode window.  If the\n *  window is a full screen window, this function does nothing.\n *\n *  __Do not use this function__ to move an already visible window unless you\n *  have very good reasons for doing so, as it will confuse and annoy the user.\n *\n *  The window manager may put limits on what positions are allowed.  GLFW\n *  cannot and should not override these limits.\n *\n *  @param[in] window The window to query.\n *  @param[in] xpos The x-coordinate of the upper-left corner of the content area.\n *  @param[in] ypos The y-coordinate of the upper-left corner of the content area.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @wayland There is no way for an application to set the global\n *  position of its windows, this function will always emit @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_pos\n *  @sa @ref glfwGetWindowPos\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowPos"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "width", :type "int *"} {:spelling "height", :type "int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "glfwGetWindowSize", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetWindowSize, :raw-comment "/*! @brief Retrieves the size of the content area of the specified window.\n *\n *  This function retrieves the size, in screen coordinates, of the content area\n *  of the specified window.  If you wish to retrieve the size of the\n *  framebuffer of the window in pixels, see @ref glfwGetFramebufferSize.\n *\n *  Any or all of the size arguments may be `NULL`.  If an error occurs, all\n *  non-`NULL` size arguments will be set to zero.\n *\n *  @param[in] window The window whose size to retrieve.\n *  @param[out] width Where to store the width, in screen coordinates, of the\n *  content area, or `NULL`.\n *  @param[out] height Where to store the height, in screen coordinates, of the\n *  content area, or `NULL`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_size\n *  @sa @ref glfwSetWindowSize\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetWindowSize"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "minwidth", :type "int"} {:spelling "minheight", :type "int"} {:spelling "maxwidth", :type "int"} {:spelling "maxheight", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glfwSetWindowSizeLimits", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowSizeLimits, :raw-comment "/*! @brief Sets the size limits of the specified window.\n *\n *  This function sets the size limits of the content area of the specified\n *  window.  If the window is full screen, the size limits only take effect\n *  once it is made windowed.  If the window is not resizable, this function\n *  does nothing.\n *\n *  The size limits are applied immediately to a windowed mode window and may\n *  cause it to be resized.\n *\n *  The maximum dimensions must be greater than or equal to the minimum\n *  dimensions and all must be greater than or equal to zero.\n *\n *  @param[in] window The window to set limits for.\n *  @param[in] minwidth The minimum width, in screen coordinates, of the content\n *  area, or `GLFW_DONT_CARE`.\n *  @param[in] minheight The minimum height, in screen coordinates, of the\n *  content area, or `GLFW_DONT_CARE`.\n *  @param[in] maxwidth The maximum width, in screen coordinates, of the content\n *  area, or `GLFW_DONT_CARE`.\n *  @param[in] maxheight The maximum height, in screen coordinates, of the\n *  content area, or `GLFW_DONT_CARE`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark If you set size limits and an aspect ratio that conflict, the\n *  results are undefined.\n *\n *  @remark @wayland The size limits will not be applied until the window is\n *  actually resized, either by the user or by the compositor.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_sizelimits\n *  @sa @ref glfwSetWindowAspectRatio\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowSizeLimits"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "numer", :type "int"} {:spelling "denom", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int], :symbol "glfwSetWindowAspectRatio", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowAspectRatio, :raw-comment "/*! @brief Sets the aspect ratio of the specified window.\n *\n *  This function sets the required aspect ratio of the content area of the\n *  specified window.  If the window is full screen, the aspect ratio only takes\n *  effect once it is made windowed.  If the window is not resizable, this\n *  function does nothing.\n *\n *  The aspect ratio is specified as a numerator and a denominator and both\n *  values must be greater than zero.  For example, the common 16:9 aspect ratio\n *  is specified as 16 and 9, respectively.\n *\n *  If the numerator and denominator is set to `GLFW_DONT_CARE` then the aspect\n *  ratio limit is disabled.\n *\n *  The aspect ratio is applied immediately to a windowed mode window and may\n *  cause it to be resized.\n *\n *  @param[in] window The window to set limits for.\n *  @param[in] numer The numerator of the desired aspect ratio, or\n *  `GLFW_DONT_CARE`.\n *  @param[in] denom The denominator of the desired aspect ratio, or\n *  `GLFW_DONT_CARE`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark If you set size limits and an aspect ratio that conflict, the\n *  results are undefined.\n *\n *  @remark @wayland The aspect ratio will not be applied until the window is\n *  actually resized, either by the user or by the compositor.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_sizelimits\n *  @sa @ref glfwSetWindowSizeLimits\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowAspectRatio"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "width", :type "int"} {:spelling "height", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int], :symbol "glfwSetWindowSize", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowSize, :raw-comment "/*! @brief Sets the size of the content area of the specified window.\n *\n *  This function sets the size, in screen coordinates, of the content area of\n *  the specified window.\n *\n *  For full screen windows, this function updates the resolution of its desired\n *  video mode and switches to the video mode closest to it, without affecting\n *  the window's context.  As the context is unaffected, the bit depths of the\n *  framebuffer remain unchanged.\n *\n *  If you wish to update the refresh rate of the desired video mode in addition\n *  to its resolution, see @ref glfwSetWindowMonitor.\n *\n *  The window manager may put limits on what sizes are allowed.  GLFW cannot\n *  and should not override these limits.\n *\n *  @param[in] window The window to resize.\n *  @param[in] width The desired width, in screen coordinates, of the window\n *  content area.\n *  @param[in] height The desired height, in screen coordinates, of the window\n *  content area.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @wayland A full screen window will not attempt to change the mode,\n *  no matter what the requested size.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_size\n *  @sa @ref glfwGetWindowSize\n *  @sa @ref glfwSetWindowMonitor\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowSize"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "width", :type "int *"} {:spelling "height", :type "int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "glfwGetFramebufferSize", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetFramebufferSize, :raw-comment "/*! @brief Retrieves the size of the framebuffer of the specified window.\n *\n *  This function retrieves the size, in pixels, of the framebuffer of the\n *  specified window.  If you wish to retrieve the size of the window in screen\n *  coordinates, see @ref glfwGetWindowSize.\n *\n *  Any or all of the size arguments may be `NULL`.  If an error occurs, all\n *  non-`NULL` size arguments will be set to zero.\n *\n *  @param[in] window The window whose framebuffer to query.\n *  @param[out] width Where to store the width, in pixels, of the framebuffer,\n *  or `NULL`.\n *  @param[out] height Where to store the height, in pixels, of the framebuffer,\n *  or `NULL`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_fbsize\n *  @sa @ref glfwSetFramebufferSizeCallback\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetFramebufferSize"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "left", :type "int *"} {:spelling "top", :type "int *"} {:spelling "right", :type "int *"} {:spelling "bottom", :type "int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "glfwGetWindowFrameSize", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetWindowFrameSize, :raw-comment "/*! @brief Retrieves the size of the frame of the window.\n *\n *  This function retrieves the size, in screen coordinates, of each edge of the\n *  frame of the specified window.  This size includes the title bar, if the\n *  window has one.  The size of the frame may vary depending on the\n *  [window-related hints](@ref window_hints_wnd) used to create it.\n *\n *  Because this function retrieves the size of each window frame edge and not\n *  the offset along a particular coordinate axis, the retrieved values will\n *  always be zero or positive.\n *\n *  Any or all of the size arguments may be `NULL`.  If an error occurs, all\n *  non-`NULL` size arguments will be set to zero.\n *\n *  @param[in] window The window whose frame size to query.\n *  @param[out] left Where to store the size, in screen coordinates, of the left\n *  edge of the window frame, or `NULL`.\n *  @param[out] top Where to store the size, in screen coordinates, of the top\n *  edge of the window frame, or `NULL`.\n *  @param[out] right Where to store the size, in screen coordinates, of the\n *  right edge of the window frame, or `NULL`.\n *  @param[out] bottom Where to store the size, in screen coordinates, of the\n *  bottom edge of the window frame, or `NULL`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_size\n *\n *  @since Added in version 3.1.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetWindowFrameSize"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "xscale", :type "float *"} {:spelling "yscale", :type "float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.mem/pointer :coffi.mem/float] [:coffi.mem/pointer :coffi.mem/float]], :symbol "glfwGetWindowContentScale", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetWindowContentScale, :raw-comment "/*! @brief Retrieves the content scale for the specified window.\n *\n *  This function retrieves the content scale for the specified window.  The\n *  content scale is the ratio between the current DPI and the platform's\n *  default DPI.  This is especially important for text and any UI elements.  If\n *  the pixel dimensions of your UI scaled by this look appropriate on your\n *  machine then it should appear at a reasonable size on other machines\n *  regardless of their DPI and scaling settings.  This relies on the system DPI\n *  and scaling settings being somewhat correct.\n *\n *  On systems where each monitors can have its own content scale, the window\n *  content scale will depend on which monitor the system considers the window\n *  to be on.\n *\n *  @param[in] window The window to query.\n *  @param[out] xscale Where to store the x-axis content scale, or `NULL`.\n *  @param[out] yscale Where to store the y-axis content scale, or `NULL`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_scale\n *  @sa @ref glfwSetWindowContentScaleCallback\n *  @sa @ref glfwGetMonitorContentScale\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetWindowContentScale"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "float"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwGetWindowOpacity", :function/ret :coffi.mem/float, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetWindowOpacity, :raw-comment "/*! @brief Returns the opacity of the whole window.\n *\n *  This function returns the opacity of the window, including any decorations.\n *\n *  The opacity (or alpha) value is a positive finite number between zero and\n *  one, where zero is fully transparent and one is fully opaque.  If the system\n *  does not support whole window transparency, this function always returns one.\n *\n *  The initial opacity value for newly created windows is one.\n *\n *  @param[in] window The window to query.\n *  @return The opacity value of the specified window.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_transparency\n *  @sa @ref glfwSetWindowOpacity\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetWindowOpacity"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "opacity", :type "float"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/float], :symbol "glfwSetWindowOpacity", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowOpacity, :raw-comment "/*! @brief Sets the opacity of the whole window.\n *\n *  This function sets the opacity of the window, including any decorations.\n *\n *  The opacity (or alpha) value is a positive finite number between zero and\n *  one, where zero is fully transparent and one is fully opaque.\n *\n *  The initial opacity value for newly created windows is one.\n *\n *  A window created with framebuffer transparency may not use whole window\n *  transparency.  The results of doing this are undefined.\n *\n *  @param[in] window The window to set the opacity for.\n *  @param[in] opacity The desired opacity of the specified window.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_transparency\n *  @sa @ref glfwGetWindowOpacity\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowOpacity"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwIconifyWindow", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwIconifyWindow, :raw-comment "/*! @brief Iconifies the specified window.\n *\n *  This function iconifies (minimizes) the specified window if it was\n *  previously restored.  If the window is already iconified, this function does\n *  nothing.\n *\n *  If the specified window is a full screen window, GLFW restores the original\n *  video mode of the monitor.  The window's desired video mode is set again\n *  when the window is restored.\n *\n *  @param[in] window The window to iconify.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_iconify\n *  @sa @ref glfwRestoreWindow\n *  @sa @ref glfwMaximizeWindow\n *\n *  @since Added in version 2.1.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwIconifyWindow"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwRestoreWindow", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwRestoreWindow, :raw-comment "/*! @brief Restores the specified window.\n *\n *  This function restores the specified window if it was previously iconified\n *  (minimized) or maximized.  If the window is already restored, this function\n *  does nothing.\n *\n *  If the specified window is an iconified full screen window, its desired\n *  video mode is set again for its monitor when the window is restored.\n *\n *  @param[in] window The window to restore.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_iconify\n *  @sa @ref glfwIconifyWindow\n *  @sa @ref glfwMaximizeWindow\n *\n *  @since Added in version 2.1.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwRestoreWindow"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwMaximizeWindow", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwMaximizeWindow, :raw-comment "/*! @brief Maximizes the specified window.\n *\n *  This function maximizes the specified window if it was previously not\n *  maximized.  If the window is already maximized, this function does nothing.\n *\n *  If the specified window is a full screen window, this function does nothing.\n *\n *  @param[in] window The window to maximize.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @par Thread Safety\n *  This function may only be called from the main thread.\n *\n *  @sa @ref window_iconify\n *  @sa @ref glfwIconifyWindow\n *  @sa @ref glfwRestoreWindow\n *\n *  @since Added in GLFW 3.2.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwMaximizeWindow"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwShowWindow", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwShowWindow, :raw-comment "/*! @brief Makes the specified window visible.\n *\n *  This function makes the specified window visible if it was previously\n *  hidden.  If the window is already visible or is in full screen mode, this\n *  function does nothing.\n *\n *  By default, windowed mode windows are focused when shown\n *  Set the [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_hint) window hint\n *  to change this behavior for all newly created windows, or change the\n *  behavior for an existing window with @ref glfwSetWindowAttrib.\n *\n *  @param[in] window The window to make visible.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @wayland Because Wayland wants every frame of the desktop to be\n *  complete, this function does not immediately make the window visible.\n *  Instead it will become visible the next time the window framebuffer is\n *  updated after this call.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_hide\n *  @sa @ref glfwHideWindow\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwShowWindow"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwHideWindow", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwHideWindow, :raw-comment "/*! @brief Hides the specified window.\n *\n *  This function hides the specified window if it was previously visible.  If\n *  the window is already hidden or is in full screen mode, this function does\n *  nothing.\n *\n *  @param[in] window The window to hide.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_hide\n *  @sa @ref glfwShowWindow\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwHideWindow"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwFocusWindow", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwFocusWindow, :raw-comment "/*! @brief Brings the specified window to front and sets input focus.\n *\n *  This function brings the specified window to front and sets input focus.\n *  The window should already be visible and not iconified.\n *\n *  By default, both windowed and full screen mode windows are focused when\n *  initially created.  Set the [GLFW_FOCUSED](@ref GLFW_FOCUSED_hint) to\n *  disable this behavior.\n *\n *  Also by default, windowed mode windows are focused when shown\n *  with @ref glfwShowWindow. Set the\n *  [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_hint) to disable this behavior.\n *\n *  __Do not use this function__ to steal focus from other applications unless\n *  you are certain that is what the user wants.  Focus stealing can be\n *  extremely disruptive.\n *\n *  For a less disruptive way of getting the user's attention, see\n *  [attention requests](@ref window_attention).\n *\n *  @param[in] window The window to give input focus.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @wayland It is not possible for an application to bring its windows\n *  to front, this function will always emit @ref GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_focus\n *  @sa @ref window_attention\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwFocusWindow"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwRequestWindowAttention", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwRequestWindowAttention, :raw-comment "/*! @brief Requests user attention to the specified window.\n *\n *  This function requests user attention to the specified window.  On\n *  platforms where this is not supported, attention is requested to the\n *  application as a whole.\n *\n *  Once the user has given attention, usually by focusing the window or\n *  application, the system will end the request automatically.\n *\n *  @param[in] window The window to request attention to.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @macos Attention is requested to the application as a whole, not the\n *  specific window.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_attention\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwRequestWindowAttention"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "struct GLFWmonitor *"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwGetWindowMonitor", :function/ret [:coffi.mem/pointer :clong/GLFWmonitor], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetWindowMonitor, :raw-comment "/*! @brief Returns the monitor that the window uses for full screen mode.\n *\n *  This function returns the handle of the monitor that the specified window is\n *  in full screen on.\n *\n *  @param[in] window The window to query.\n *  @return The monitor, or `NULL` if the window is in windowed mode or an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_monitor\n *  @sa @ref glfwSetWindowMonitor\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetWindowMonitor"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "monitor", :type "struct GLFWmonitor *"} {:spelling "xpos", :type "int"} {:spelling "ypos", :type "int"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "refreshRate", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.mem/pointer :clong/GLFWmonitor] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "glfwSetWindowMonitor", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowMonitor, :raw-comment "/*! @brief Sets the mode, monitor, video mode and placement of a window.\n *\n *  This function sets the monitor that the window uses for full screen mode or,\n *  if the monitor is `NULL`, makes it windowed mode.\n *\n *  When setting a monitor, this function updates the width, height and refresh\n *  rate of the desired video mode and switches to the video mode closest to it.\n *  The window position is ignored when setting a monitor.\n *\n *  When the monitor is `NULL`, the position, width and height are used to\n *  place the window content area.  The refresh rate is ignored when no monitor\n *  is specified.\n *\n *  If you only wish to update the resolution of a full screen window or the\n *  size of a windowed mode window, see @ref glfwSetWindowSize.\n *\n *  When a window transitions from full screen to windowed mode, this function\n *  restores any previous window settings such as whether it is decorated,\n *  floating, resizable, has size or aspect ratio limits, etc.\n *\n *  @param[in] window The window whose monitor, size or video mode to set.\n *  @param[in] monitor The desired monitor, or `NULL` to set windowed mode.\n *  @param[in] xpos The desired x-coordinate of the upper-left corner of the\n *  content area.\n *  @param[in] ypos The desired y-coordinate of the upper-left corner of the\n *  content area.\n *  @param[in] width The desired with, in screen coordinates, of the content\n *  area or video mode.\n *  @param[in] height The desired height, in screen coordinates, of the content\n *  area or video mode.\n *  @param[in] refreshRate The desired refresh rate, in Hz, of the video mode,\n *  or `GLFW_DONT_CARE`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark The OpenGL or OpenGL ES context will not be destroyed or otherwise\n *  affected by any resizing or mode switching, although you may need to update\n *  your viewport if the framebuffer size has changed.\n *\n *  @remark @wayland The desired window position is ignored, as there is no way\n *  for an application to set this property.\n *\n *  @remark @wayland Setting the window to full screen will not attempt to\n *  change the mode, no matter what the requested size or refresh rate.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_monitor\n *  @sa @ref window_full_screen\n *  @sa @ref glfwGetWindowMonitor\n *  @sa @ref glfwSetWindowSize\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowMonitor"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "attrib", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int], :symbol "glfwGetWindowAttrib", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetWindowAttrib, :raw-comment "/*! @brief Returns an attribute of the specified window.\n *\n *  This function returns the value of an attribute of the specified window or\n *  its OpenGL or OpenGL ES context.\n *\n *  @param[in] window The window to query.\n *  @param[in] attrib The [window attribute](@ref window_attribs) whose value to\n *  return.\n *  @return The value of the attribute, or zero if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark Framebuffer related hints are not window attributes.  See @ref\n *  window_attribs_fb for more information.\n *\n *  @remark Zero is a valid value for many window and context related\n *  attributes so you cannot use a return value of zero as an indication of\n *  errors.  However, this function should not fail as long as it is passed\n *  valid arguments and the library has been [initialized](@ref intro_init).\n *\n *  @remark @wayland The Wayland protocol provides no way to check whether a\n *  window is iconfied, so @ref GLFW_ICONIFIED always returns `GLFW_FALSE`.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_attribs\n *  @sa @ref glfwSetWindowAttrib\n *\n *  @since Added in version 3.0.  Replaces `glfwGetWindowParam` and\n *  `glfwGetGLVersion`.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetWindowAttrib"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "attrib", :type "int"} {:spelling "value", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int], :symbol "glfwSetWindowAttrib", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowAttrib, :raw-comment "/*! @brief Sets an attribute of the specified window.\n *\n *  This function sets the value of an attribute of the specified window.\n *\n *  The supported attributes are [GLFW_DECORATED](@ref GLFW_DECORATED_attrib),\n *  [GLFW_RESIZABLE](@ref GLFW_RESIZABLE_attrib),\n *  [GLFW_FLOATING](@ref GLFW_FLOATING_attrib),\n *  [GLFW_AUTO_ICONIFY](@ref GLFW_AUTO_ICONIFY_attrib) and\n *  [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_attrib).\n *\n *  Some of these attributes are ignored for full screen windows.  The new\n *  value will take effect if the window is later made windowed.\n *\n *  Some of these attributes are ignored for windowed mode windows.  The new\n *  value will take effect if the window is later made full screen.\n *\n *  @param[in] window The window to set the attribute for.\n *  @param[in] attrib A supported window attribute.\n *  @param[in] value `GLFW_TRUE` or `GLFW_FALSE`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM, @ref GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark Calling @ref glfwGetWindowAttrib will always return the latest\n *  value, even if that value is ignored by the current mode of the window.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_attribs\n *  @sa @ref glfwGetWindowAttrib\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowAttrib"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "pointer", :type "void *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/pointer], :symbol "glfwSetWindowUserPointer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowUserPointer, :raw-comment "/*! @brief Sets the user pointer of the specified window.\n *\n *  This function sets the user-defined pointer of the specified window.  The\n *  current value is retained until the window is destroyed.  The initial value\n *  is `NULL`.\n *\n *  @param[in] window The window whose pointer to set.\n *  @param[in] pointer The new value.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref window_userptr\n *  @sa @ref glfwGetWindowUserPointer\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowUserPointer"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwGetWindowUserPointer", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetWindowUserPointer, :raw-comment "/*! @brief Returns the user pointer of the specified window.\n *\n *  This function returns the current value of the user-defined pointer of the\n *  specified window.  The initial value is `NULL`.\n *\n *  @param[in] window The window whose pointer to return.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref window_userptr\n *  @sa @ref glfwSetWindowUserPointer\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetWindowUserPointer"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, int, int)"}], :ret {:spelling "void (*)(struct GLFWwindow *, int, int)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int] :coffi.mem/void]], :symbol "glfwSetWindowPosCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowPosCallback, :raw-comment "/*! @brief Sets the position callback for the specified window.\n *\n *  This function sets the position callback of the specified window, which is\n *  called when the window is moved.  The callback is provided with the\n *  position, in screen coordinates, of the upper-left corner of the content\n *  area of the window.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, int xpos, int ypos)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWwindowposfun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @remark @wayland This callback will never be called, as there is no way for\n *  an application to know its global position.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_pos\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowPosCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, int, int)"}], :ret {:spelling "void (*)(struct GLFWwindow *, int, int)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int] :coffi.mem/void]], :symbol "glfwSetWindowSizeCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowSizeCallback, :raw-comment "/*! @brief Sets the size callback for the specified window.\n *\n *  This function sets the size callback of the specified window, which is\n *  called when the window is resized.  The callback is provided with the size,\n *  in screen coordinates, of the content area of the window.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, int width, int height)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWwindowsizefun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_size\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter and return value.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowSizeCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *)"}], :ret {:spelling "void (*)(struct GLFWwindow *)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow]] :coffi.mem/void]], :symbol "glfwSetWindowCloseCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow]] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowCloseCallback, :raw-comment "/*! @brief Sets the close callback for the specified window.\n *\n *  This function sets the close callback of the specified window, which is\n *  called when the user attempts to close the window, for example by clicking\n *  the close widget in the title bar.\n *\n *  The close flag is set before this callback is called, but you can modify it\n *  at any time with @ref glfwSetWindowShouldClose.\n *\n *  The close callback is not triggered by @ref glfwDestroyWindow.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWwindowclosefun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @remark @macos Selecting Quit from the application menu will trigger the\n *  close callback for all windows.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_close\n *\n *  @since Added in version 2.5.\n *  @glfw3 Added window handle parameter and return value.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowCloseCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *)"}], :ret {:spelling "void (*)(struct GLFWwindow *)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow]] :coffi.mem/void]], :symbol "glfwSetWindowRefreshCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow]] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowRefreshCallback, :raw-comment "/*! @brief Sets the refresh callback for the specified window.\n *\n *  This function sets the refresh callback of the specified window, which is\n *  called when the content area of the window needs to be redrawn, for example\n *  if the window has been exposed after having been covered by another window.\n *\n *  On compositing window systems such as Aero, Compiz, Aqua or Wayland, where\n *  the window contents are saved off-screen, this callback may be called only\n *  very infrequently or never at all.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window);\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWwindowrefreshfun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_refresh\n *\n *  @since Added in version 2.5.\n *  @glfw3 Added window handle parameter and return value.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowRefreshCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, int)"}], :ret {:spelling "void (*)(struct GLFWwindow *, int)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int] :coffi.mem/void]], :symbol "glfwSetWindowFocusCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowFocusCallback, :raw-comment "/*! @brief Sets the focus callback for the specified window.\n *\n *  This function sets the focus callback of the specified window, which is\n *  called when the window gains or loses input focus.\n *\n *  After the focus callback is called for a window that lost input focus,\n *  synthetic key and mouse button release events will be generated for all such\n *  that had been pressed.  For more information, see @ref glfwSetKeyCallback\n *  and @ref glfwSetMouseButtonCallback.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, int focused)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWwindowfocusfun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_focus\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowFocusCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, int)"}], :ret {:spelling "void (*)(struct GLFWwindow *, int)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int] :coffi.mem/void]], :symbol "glfwSetWindowIconifyCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowIconifyCallback, :raw-comment "/*! @brief Sets the iconify callback for the specified window.\n *\n *  This function sets the iconification callback of the specified window, which\n *  is called when the window is iconified or restored.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, int iconified)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWwindowiconifyfun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @remark @wayland The XDG-shell protocol has no event for iconification, so\n *  this callback will never be called.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_iconify\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowIconifyCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, int)"}], :ret {:spelling "void (*)(struct GLFWwindow *, int)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int] :coffi.mem/void]], :symbol "glfwSetWindowMaximizeCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowMaximizeCallback, :raw-comment "/*! @brief Sets the maximize callback for the specified window.\n *\n *  This function sets the maximization callback of the specified window, which\n *  is called when the window is maximized or restored.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, int maximized)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWwindowmaximizefun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_maximize\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowMaximizeCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, int, int)"}], :ret {:spelling "void (*)(struct GLFWwindow *, int, int)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int] :coffi.mem/void]], :symbol "glfwSetFramebufferSizeCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetFramebufferSizeCallback, :raw-comment "/*! @brief Sets the framebuffer resize callback for the specified window.\n *\n *  This function sets the framebuffer resize callback of the specified window,\n *  which is called when the framebuffer of the specified window is resized.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, int width, int height)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWframebuffersizefun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_fbsize\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetFramebufferSizeCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, float, float)"}], :ret {:spelling "void (*)(struct GLFWwindow *, float, float)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/float :coffi.mem/float] :coffi.mem/void]], :symbol "glfwSetWindowContentScaleCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/float :coffi.mem/float] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetWindowContentScaleCallback, :raw-comment "/*! @brief Sets the window content scale callback for the specified window.\n *\n *  This function sets the window content scale callback of the specified window,\n *  which is called when the content scale of the specified window changes.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, float xscale, float yscale)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWwindowcontentscalefun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_scale\n *  @sa @ref glfwGetWindowContentScale\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetWindowContentScaleCallback"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glfwPollEvents", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwPollEvents, :raw-comment "/*! @brief Processes all pending events.\n *\n *  This function processes only those events that are already in the event\n *  queue and then returns immediately.  Processing events will cause the window\n *  and input callbacks associated with those events to be called.\n *\n *  On some platforms, a window move, resize or menu operation will cause event\n *  processing to block.  This is due to how event processing is designed on\n *  those platforms.  You can use the\n *  [window refresh callback](@ref window_refresh) to redraw the contents of\n *  your window when necessary during such operations.\n *\n *  Do not assume that callbacks you set will _only_ be called in response to\n *  event processing functions like this one.  While it is necessary to poll for\n *  events, window systems that require GLFW to register callbacks of its own\n *  can pass events to GLFW in response to many window system function calls.\n *  GLFW will pass those events on to the application callbacks before\n *  returning.\n *\n *  Event processing is not required for joystick input to work.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @reentrancy This function must not be called from a callback.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref events\n *  @sa @ref glfwWaitEvents\n *  @sa @ref glfwWaitEventsTimeout\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwPollEvents"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glfwWaitEvents", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwWaitEvents, :raw-comment "/*! @brief Waits until events are queued and processes them.\n *\n *  This function puts the calling thread to sleep until at least one event is\n *  available in the event queue.  Once one or more events are available,\n *  it behaves exactly like @ref glfwPollEvents, i.e. the events in the queue\n *  are processed and the function then returns immediately.  Processing events\n *  will cause the window and input callbacks associated with those events to be\n *  called.\n *\n *  Since not all events are associated with callbacks, this function may return\n *  without a callback having been called even if you are monitoring all\n *  callbacks.\n *\n *  On some platforms, a window move, resize or menu operation will cause event\n *  processing to block.  This is due to how event processing is designed on\n *  those platforms.  You can use the\n *  [window refresh callback](@ref window_refresh) to redraw the contents of\n *  your window when necessary during such operations.\n *\n *  Do not assume that callbacks you set will _only_ be called in response to\n *  event processing functions like this one.  While it is necessary to poll for\n *  events, window systems that require GLFW to register callbacks of its own\n *  can pass events to GLFW in response to many window system function calls.\n *  GLFW will pass those events on to the application callbacks before\n *  returning.\n *\n *  Event processing is not required for joystick input to work.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @reentrancy This function must not be called from a callback.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref events\n *  @sa @ref glfwPollEvents\n *  @sa @ref glfwWaitEventsTimeout\n *\n *  @since Added in version 2.5.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwWaitEvents"} {:args [{:spelling "timeout", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double], :symbol "glfwWaitEventsTimeout", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwWaitEventsTimeout, :raw-comment "/*! @brief Waits with timeout until events are queued and processes them.\n *\n *  This function puts the calling thread to sleep until at least one event is\n *  available in the event queue, or until the specified timeout is reached.  If\n *  one or more events are available, it behaves exactly like @ref\n *  glfwPollEvents, i.e. the events in the queue are processed and the function\n *  then returns immediately.  Processing events will cause the window and input\n *  callbacks associated with those events to be called.\n *\n *  The timeout value must be a positive finite number.\n *\n *  Since not all events are associated with callbacks, this function may return\n *  without a callback having been called even if you are monitoring all\n *  callbacks.\n *\n *  On some platforms, a window move, resize or menu operation will cause event\n *  processing to block.  This is due to how event processing is designed on\n *  those platforms.  You can use the\n *  [window refresh callback](@ref window_refresh) to redraw the contents of\n *  your window when necessary during such operations.\n *\n *  Do not assume that callbacks you set will _only_ be called in response to\n *  event processing functions like this one.  While it is necessary to poll for\n *  events, window systems that require GLFW to register callbacks of its own\n *  can pass events to GLFW in response to many window system function calls.\n *  GLFW will pass those events on to the application callbacks before\n *  returning.\n *\n *  Event processing is not required for joystick input to work.\n *\n *  @param[in] timeout The maximum amount of time, in seconds, to wait.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @reentrancy This function must not be called from a callback.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref events\n *  @sa @ref glfwPollEvents\n *  @sa @ref glfwWaitEvents\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwWaitEventsTimeout"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "glfwPostEmptyEvent", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwPostEmptyEvent, :raw-comment "/*! @brief Posts an empty event to the event queue.\n *\n *  This function posts an empty event from the current thread to the event\n *  queue, causing @ref glfwWaitEvents or @ref glfwWaitEventsTimeout to return.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref events\n *  @sa @ref glfwWaitEvents\n *  @sa @ref glfwWaitEventsTimeout\n *\n *  @since Added in version 3.1.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwPostEmptyEvent"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "mode", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int], :symbol "glfwGetInputMode", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetInputMode, :raw-comment "/*! @brief Returns the value of an input option for the specified window.\n *\n *  This function returns the value of an input option for the specified window.\n *  The mode must be one of @ref GLFW_CURSOR, @ref GLFW_STICKY_KEYS,\n *  @ref GLFW_STICKY_MOUSE_BUTTONS, @ref GLFW_LOCK_KEY_MODS or\n *  @ref GLFW_RAW_MOUSE_MOTION.\n *\n *  @param[in] window The window to query.\n *  @param[in] mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,\n *  `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or\n *  `GLFW_RAW_MOUSE_MOTION`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_ENUM.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref glfwSetInputMode\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetInputMode"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "mode", :type "int"} {:spelling "value", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int], :symbol "glfwSetInputMode", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetInputMode, :raw-comment "/*! @brief Sets an input option for the specified window.\n *\n *  This function sets an input mode option for the specified window.  The mode\n *  must be one of @ref GLFW_CURSOR, @ref GLFW_STICKY_KEYS,\n *  @ref GLFW_STICKY_MOUSE_BUTTONS, @ref GLFW_LOCK_KEY_MODS or\n *  @ref GLFW_RAW_MOUSE_MOTION.\n *\n *  If the mode is `GLFW_CURSOR`, the value must be one of the following cursor\n *  modes:\n *  - `GLFW_CURSOR_NORMAL` makes the cursor visible and behaving normally.\n *  - `GLFW_CURSOR_HIDDEN` makes the cursor invisible when it is over the\n *    content area of the window but does not restrict the cursor from leaving.\n *  - `GLFW_CURSOR_DISABLED` hides and grabs the cursor, providing virtual\n *    and unlimited cursor movement.  This is useful for implementing for\n *    example 3D camera controls.\n *\n *  If the mode is `GLFW_STICKY_KEYS`, the value must be either `GLFW_TRUE` to\n *  enable sticky keys, or `GLFW_FALSE` to disable it.  If sticky keys are\n *  enabled, a key press will ensure that @ref glfwGetKey returns `GLFW_PRESS`\n *  the next time it is called even if the key had been released before the\n *  call.  This is useful when you are only interested in whether keys have been\n *  pressed but not when or in which order.\n *\n *  If the mode is `GLFW_STICKY_MOUSE_BUTTONS`, the value must be either\n *  `GLFW_TRUE` to enable sticky mouse buttons, or `GLFW_FALSE` to disable it.\n *  If sticky mouse buttons are enabled, a mouse button press will ensure that\n *  @ref glfwGetMouseButton returns `GLFW_PRESS` the next time it is called even\n *  if the mouse button had been released before the call.  This is useful when\n *  you are only interested in whether mouse buttons have been pressed but not\n *  when or in which order.\n *\n *  If the mode is `GLFW_LOCK_KEY_MODS`, the value must be either `GLFW_TRUE` to\n *  enable lock key modifier bits, or `GLFW_FALSE` to disable them.  If enabled,\n *  callbacks that receive modifier bits will also have the @ref\n *  GLFW_MOD_CAPS_LOCK bit set when the event was generated with Caps Lock on,\n *  and the @ref GLFW_MOD_NUM_LOCK bit when Num Lock was on.\n *\n *  If the mode is `GLFW_RAW_MOUSE_MOTION`, the value must be either `GLFW_TRUE`\n *  to enable raw (unscaled and unaccelerated) mouse motion when the cursor is\n *  disabled, or `GLFW_FALSE` to disable it.  If raw motion is not supported,\n *  attempting to set this will emit @ref GLFW_PLATFORM_ERROR.  Call @ref\n *  glfwRawMouseMotionSupported to check for support.\n *\n *  @param[in] window The window whose input mode to set.\n *  @param[in] mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,\n *  `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or\n *  `GLFW_RAW_MOUSE_MOTION`.\n *  @param[in] value The new value of the specified input mode.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref glfwGetInputMode\n *\n *  @since Added in version 3.0.  Replaces `glfwEnable` and `glfwDisable`.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetInputMode"} {:args [], :ret {:spelling "int"}, :function/args [], :symbol "glfwRawMouseMotionSupported", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwRawMouseMotionSupported, :raw-comment "/*! @brief Returns whether raw mouse motion is supported.\n *\n *  This function returns whether raw mouse motion is supported on the current\n *  system.  This status does not change after GLFW has been initialized so you\n *  only need to check this once.  If you attempt to enable raw motion on\n *  a system that does not support it, @ref GLFW_PLATFORM_ERROR will be emitted.\n *\n *  Raw mouse motion is closer to the actual motion of the mouse across\n *  a surface.  It is not affected by the scaling and acceleration applied to\n *  the motion of the desktop cursor.  That processing is suitable for a cursor\n *  while raw motion is better for controlling for example a 3D camera.  Because\n *  of this, raw mouse motion is only provided when the cursor is disabled.\n *\n *  @return `GLFW_TRUE` if raw mouse motion is supported on the current machine,\n *  or `GLFW_FALSE` otherwise.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref raw_mouse_motion\n *  @sa @ref glfwSetInputMode\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwRawMouseMotionSupported"} {:args [{:spelling "key", :type "int"} {:spelling "scancode", :type "int"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "glfwGetKeyName", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetKeyName, :raw-comment "/*! @brief Returns the layout-specific name of the specified printable key.\n *\n *  This function returns the name of the specified printable key, encoded as\n *  UTF-8.  This is typically the character that key would produce without any\n *  modifier keys, intended for displaying key bindings to the user.  For dead\n *  keys, it is typically the diacritic it would add to a character.\n *\n *  __Do not use this function__ for [text input](@ref input_char).  You will\n *  break text input for many languages even if it happens to work for yours.\n *\n *  If the key is `GLFW_KEY_UNKNOWN`, the scancode is used to identify the key,\n *  otherwise the scancode is ignored.  If you specify a non-printable key, or\n *  `GLFW_KEY_UNKNOWN` and a scancode that maps to a non-printable key, this\n *  function returns `NULL` but does not emit an error.\n *\n *  This behavior allows you to always pass in the arguments in the\n *  [key callback](@ref input_key) without modification.\n *\n *  The printable keys are:\n *  - `GLFW_KEY_APOSTROPHE`\n *  - `GLFW_KEY_COMMA`\n *  - `GLFW_KEY_MINUS`\n *  - `GLFW_KEY_PERIOD`\n *  - `GLFW_KEY_SLASH`\n *  - `GLFW_KEY_SEMICOLON`\n *  - `GLFW_KEY_EQUAL`\n *  - `GLFW_KEY_LEFT_BRACKET`\n *  - `GLFW_KEY_RIGHT_BRACKET`\n *  - `GLFW_KEY_BACKSLASH`\n *  - `GLFW_KEY_WORLD_1`\n *  - `GLFW_KEY_WORLD_2`\n *  - `GLFW_KEY_0` to `GLFW_KEY_9`\n *  - `GLFW_KEY_A` to `GLFW_KEY_Z`\n *  - `GLFW_KEY_KP_0` to `GLFW_KEY_KP_9`\n *  - `GLFW_KEY_KP_DECIMAL`\n *  - `GLFW_KEY_KP_DIVIDE`\n *  - `GLFW_KEY_KP_MULTIPLY`\n *  - `GLFW_KEY_KP_SUBTRACT`\n *  - `GLFW_KEY_KP_ADD`\n *  - `GLFW_KEY_KP_EQUAL`\n *\n *  Names for printable keys depend on keyboard layout, while names for\n *  non-printable keys are the same across layouts but depend on the application\n *  language and should be localized along with other user interface text.\n *\n *  @param[in] key The key to query, or `GLFW_KEY_UNKNOWN`.\n *  @param[in] scancode The scancode of the key to query.\n *  @return The UTF-8 encoded, layout-specific name of the key, or `NULL`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark The contents of the returned string may change when a keyboard\n *  layout change event is received.\n *\n *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref input_key_name\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetKeyName"} {:args [{:spelling "key", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "glfwGetKeyScancode", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetKeyScancode, :raw-comment "/*! @brief Returns the platform-specific scancode of the specified key.\n *\n *  This function returns the platform-specific scancode of the specified key.\n *\n *  If the key is `GLFW_KEY_UNKNOWN` or does not exist on the keyboard this\n *  method will return `-1`.\n *\n *  @param[in] key Any [named key](@ref keys).\n *  @return The platform-specific scancode for the key, or `-1` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref input_key\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetKeyScancode"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "key", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int], :symbol "glfwGetKey", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetKey, :raw-comment "/*! @brief Returns the last reported state of a keyboard key for the specified\n *  window.\n *\n *  This function returns the last state reported for the specified key to the\n *  specified window.  The returned state is one of `GLFW_PRESS` or\n *  `GLFW_RELEASE`.  The action `GLFW_REPEAT` is only reported to the key callback.\n *\n *  If the @ref GLFW_STICKY_KEYS input mode is enabled, this function returns\n *  `GLFW_PRESS` the first time you call it for a key that was pressed, even if\n *  that key has already been released.\n *\n *  The key functions deal with physical keys, with [key tokens](@ref keys)\n *  named after their use on the standard US keyboard layout.  If you want to\n *  input text, use the Unicode character callback instead.\n *\n *  The [modifier key bit masks](@ref mods) are not key tokens and cannot be\n *  used with this function.\n *\n *  __Do not use this function__ to implement [text input](@ref input_char).\n *\n *  @param[in] window The desired window.\n *  @param[in] key The desired [keyboard key](@ref keys).  `GLFW_KEY_UNKNOWN` is\n *  not a valid key for this function.\n *  @return One of `GLFW_PRESS` or `GLFW_RELEASE`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_ENUM.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref input_key\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetKey"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "button", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int], :symbol "glfwGetMouseButton", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetMouseButton, :raw-comment "/*! @brief Returns the last reported state of a mouse button for the specified\n *  window.\n *\n *  This function returns the last state reported for the specified mouse button\n *  to the specified window.  The returned state is one of `GLFW_PRESS` or\n *  `GLFW_RELEASE`.\n *\n *  If the @ref GLFW_STICKY_MOUSE_BUTTONS input mode is enabled, this function\n *  returns `GLFW_PRESS` the first time you call it for a mouse button that was\n *  pressed, even if that mouse button has already been released.\n *\n *  @param[in] window The desired window.\n *  @param[in] button The desired [mouse button](@ref buttons).\n *  @return One of `GLFW_PRESS` or `GLFW_RELEASE`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_ENUM.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref input_mouse_button\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetMouseButton"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "xpos", :type "double *"} {:spelling "ypos", :type "double *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.mem/pointer :coffi.mem/double] [:coffi.mem/pointer :coffi.mem/double]], :symbol "glfwGetCursorPos", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetCursorPos, :raw-comment "/*! @brief Retrieves the position of the cursor relative to the content area of\n *  the window.\n *\n *  This function returns the position of the cursor, in screen coordinates,\n *  relative to the upper-left corner of the content area of the specified\n *  window.\n *\n *  If the cursor is disabled (with `GLFW_CURSOR_DISABLED`) then the cursor\n *  position is unbounded and limited only by the minimum and maximum values of\n *  a `double`.\n *\n *  The coordinate can be converted to their integer equivalents with the\n *  `floor` function.  Casting directly to an integer type works for positive\n *  coordinates, but fails for negative ones.\n *\n *  Any or all of the position arguments may be `NULL`.  If an error occurs, all\n *  non-`NULL` position arguments will be set to zero.\n *\n *  @param[in] window The desired window.\n *  @param[out] xpos Where to store the cursor x-coordinate, relative to the\n *  left edge of the content area, or `NULL`.\n *  @param[out] ypos Where to store the cursor y-coordinate, relative to the to\n *  top edge of the content area, or `NULL`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref cursor_pos\n *  @sa @ref glfwSetCursorPos\n *\n *  @since Added in version 3.0.  Replaces `glfwGetMousePos`.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetCursorPos"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "xpos", :type "double"} {:spelling "ypos", :type "double"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/double :coffi.mem/double], :symbol "glfwSetCursorPos", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetCursorPos, :raw-comment "/*! @brief Sets the position of the cursor, relative to the content area of the\n *  window.\n *\n *  This function sets the position, in screen coordinates, of the cursor\n *  relative to the upper-left corner of the content area of the specified\n *  window.  The window must have input focus.  If the window does not have\n *  input focus when this function is called, it fails silently.\n *\n *  __Do not use this function__ to implement things like camera controls.  GLFW\n *  already provides the `GLFW_CURSOR_DISABLED` cursor mode that hides the\n *  cursor, transparently re-centers it and provides unconstrained cursor\n *  motion.  See @ref glfwSetInputMode for more information.\n *\n *  If the cursor mode is `GLFW_CURSOR_DISABLED` then the cursor position is\n *  unconstrained and limited only by the minimum and maximum values of\n *  a `double`.\n *\n *  @param[in] window The desired window.\n *  @param[in] xpos The desired x-coordinate, relative to the left edge of the\n *  content area.\n *  @param[in] ypos The desired y-coordinate, relative to the top edge of the\n *  content area.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @wayland This function will only work when the cursor mode is\n *  `GLFW_CURSOR_DISABLED`, otherwise it will do nothing.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref cursor_pos\n *  @sa @ref glfwGetCursorPos\n *\n *  @since Added in version 3.0.  Replaces `glfwSetMousePos`.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetCursorPos"} {:args [{:spelling "image", :type "const struct GLFWimage *"} {:spelling "xhot", :type "int"} {:spelling "yhot", :type "int"}], :ret {:spelling "struct GLFWcursor *"}, :function/args [[:coffi.mem/pointer :clong/GLFWimage] :coffi.mem/int :coffi.mem/int], :symbol "glfwCreateCursor", :function/ret [:coffi.mem/pointer :clong/GLFWcursor], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwCreateCursor, :raw-comment "/*! @brief Creates a custom cursor.\n *\n *  Creates a new custom cursor image that can be set for a window with @ref\n *  glfwSetCursor.  The cursor can be destroyed with @ref glfwDestroyCursor.\n *  Any remaining cursors are destroyed by @ref glfwTerminate.\n *\n *  The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight\n *  bits per channel with the red channel first.  They are arranged canonically\n *  as packed sequential rows, starting from the top-left corner.\n *\n *  The cursor hotspot is specified in pixels, relative to the upper-left corner\n *  of the cursor image.  Like all other coordinate systems in GLFW, the X-axis\n *  points to the right and the Y-axis points down.\n *\n *  @param[in] image The desired cursor image.\n *  @param[in] xhot The desired x-coordinate, in pixels, of the cursor hotspot.\n *  @param[in] yhot The desired y-coordinate, in pixels, of the cursor hotspot.\n *  @return The handle of the created cursor, or `NULL` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The specified image data is copied before this function\n *  returns.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref cursor_object\n *  @sa @ref glfwDestroyCursor\n *  @sa @ref glfwCreateStandardCursor\n *\n *  @since Added in version 3.1.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwCreateCursor"} {:args [{:spelling "shape", :type "int"}], :ret {:spelling "struct GLFWcursor *"}, :function/args [:coffi.mem/int], :symbol "glfwCreateStandardCursor", :function/ret [:coffi.mem/pointer :clong/GLFWcursor], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwCreateStandardCursor, :raw-comment "/*! @brief Creates a cursor with a standard shape.\n *\n *  Returns a cursor with a [standard shape](@ref shapes), that can be set for\n *  a window with @ref glfwSetCursor.\n *\n *  @param[in] shape One of the [standard shapes](@ref shapes).\n *  @return A new cursor ready to use or `NULL` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref cursor_object\n *  @sa @ref glfwCreateCursor\n *\n *  @since Added in version 3.1.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwCreateStandardCursor"} {:args [{:spelling "cursor", :type "struct GLFWcursor *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWcursor]], :symbol "glfwDestroyCursor", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwDestroyCursor, :raw-comment "/*! @brief Destroys a cursor.\n *\n *  This function destroys a cursor previously created with @ref\n *  glfwCreateCursor.  Any remaining cursors will be destroyed by @ref\n *  glfwTerminate.\n *\n *  If the specified cursor is current for any window, that window will be\n *  reverted to the default cursor.  This does not affect the cursor mode.\n *\n *  @param[in] cursor The cursor object to destroy.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @reentrancy This function must not be called from a callback.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref cursor_object\n *  @sa @ref glfwCreateCursor\n *\n *  @since Added in version 3.1.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwDestroyCursor"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "cursor", :type "struct GLFWcursor *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.mem/pointer :clong/GLFWcursor]], :symbol "glfwSetCursor", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetCursor, :raw-comment "/*! @brief Sets the cursor for the window.\n *\n *  This function sets the cursor image to be used when the cursor is over the\n *  content area of the specified window.  The set cursor will only be visible\n *  when the [cursor mode](@ref cursor_mode) of the window is\n *  `GLFW_CURSOR_NORMAL`.\n *\n *  On some platforms, the set cursor may not be visible unless the window also\n *  has input focus.\n *\n *  @param[in] window The window to set the cursor for.\n *  @param[in] cursor The cursor to set, or `NULL` to switch back to the default\n *  arrow cursor.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref cursor_object\n *\n *  @since Added in version 3.1.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetCursor"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, int, int, int, int)"}], :ret {:spelling "void (*)(struct GLFWwindow *, int, int, int, int)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int] :coffi.mem/void]], :symbol "glfwSetKeyCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetKeyCallback, :raw-comment "/*! @brief Sets the key callback.\n *\n *  This function sets the key callback of the specified window, which is called\n *  when a key is pressed, repeated or released.\n *\n *  The key functions deal with physical keys, with layout independent\n *  [key tokens](@ref keys) named after their values in the standard US keyboard\n *  layout.  If you want to input text, use the\n *  [character callback](@ref glfwSetCharCallback) instead.\n *\n *  When a window loses input focus, it will generate synthetic key release\n *  events for all pressed keys.  You can tell these events from user-generated\n *  events by the fact that the synthetic ones are generated after the focus\n *  loss event has been processed, i.e. after the\n *  [window focus callback](@ref glfwSetWindowFocusCallback) has been called.\n *\n *  The scancode of a key is specific to that platform or sometimes even to that\n *  machine.  Scancodes are intended to allow users to bind keys that don't have\n *  a GLFW key token.  Such keys have `key` set to `GLFW_KEY_UNKNOWN`, their\n *  state is not saved and so it cannot be queried with @ref glfwGetKey.\n *\n *  Sometimes GLFW needs to generate synthetic key events, in which case the\n *  scancode may be zero.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new key callback, or `NULL` to remove the currently\n *  set callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, int key, int scancode, int action, int mods)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWkeyfun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref input_key\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter and return value.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetKeyCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, unsigned int)"}], :ret {:spelling "void (*)(struct GLFWwindow *, unsigned int)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int] :coffi.mem/void]], :symbol "glfwSetCharCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetCharCallback, :raw-comment "/*! @brief Sets the Unicode character callback.\n *\n *  This function sets the character callback of the specified window, which is\n *  called when a Unicode character is input.\n *\n *  The character callback is intended for Unicode text input.  As it deals with\n *  characters, it is keyboard layout dependent, whereas the\n *  [key callback](@ref glfwSetKeyCallback) is not.  Characters do not map 1:1\n *  to physical keys, as a key may produce zero, one or more characters.  If you\n *  want to know whether a specific physical key was pressed or released, see\n *  the key callback instead.\n *\n *  The character callback behaves as system text input normally does and will\n *  not be called if modifier keys are held down that would prevent normal text\n *  input on that platform, for example a Super (Command) key on macOS or Alt key\n *  on Windows.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, unsigned int codepoint)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWcharfun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref input_char\n *\n *  @since Added in version 2.4.\n *  @glfw3 Added window handle parameter and return value.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetCharCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, unsigned int, int)"}], :ret {:spelling "void (*)(struct GLFWwindow *, unsigned int, int)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int] :coffi.mem/void]], :symbol "glfwSetCharModsCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetCharModsCallback, :raw-comment "/*! @brief Sets the Unicode character with modifiers callback.\n *\n *  This function sets the character with modifiers callback of the specified\n *  window, which is called when a Unicode character is input regardless of what\n *  modifier keys are used.\n *\n *  The character with modifiers callback is intended for implementing custom\n *  Unicode character input.  For regular Unicode text input, see the\n *  [character callback](@ref glfwSetCharCallback).  Like the character\n *  callback, the character with modifiers callback deals with characters and is\n *  keyboard layout dependent.  Characters do not map 1:1 to physical keys, as\n *  a key may produce zero, one or more characters.  If you want to know whether\n *  a specific physical key was pressed or released, see the\n *  [key callback](@ref glfwSetKeyCallback) instead.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or an\n *  [error](@ref error_handling) occurred.\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, unsigned int codepoint, int mods)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWcharmodsfun).\n *\n *  @deprecated Scheduled for removal in version 4.0.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref input_char\n *\n *  @since Added in version 3.1.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetCharModsCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, int, int, int)"}], :ret {:spelling "void (*)(struct GLFWwindow *, int, int, int)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int :coffi.mem/int] :coffi.mem/void]], :symbol "glfwSetMouseButtonCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int :coffi.mem/int :coffi.mem/int] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetMouseButtonCallback, :raw-comment "/*! @brief Sets the mouse button callback.\n *\n *  This function sets the mouse button callback of the specified window, which\n *  is called when a mouse button is pressed or released.\n *\n *  When a window loses input focus, it will generate synthetic mouse button\n *  release events for all pressed mouse buttons.  You can tell these events\n *  from user-generated events by the fact that the synthetic ones are generated\n *  after the focus loss event has been processed, i.e. after the\n *  [window focus callback](@ref glfwSetWindowFocusCallback) has been called.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, int button, int action, int mods)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWmousebuttonfun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref input_mouse_button\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter and return value.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetMouseButtonCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, double, double)"}], :ret {:spelling "void (*)(struct GLFWwindow *, double, double)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/double :coffi.mem/double] :coffi.mem/void]], :symbol "glfwSetCursorPosCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/double :coffi.mem/double] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetCursorPosCallback, :raw-comment "/*! @brief Sets the cursor position callback.\n *\n *  This function sets the cursor position callback of the specified window,\n *  which is called when the cursor is moved.  The callback is provided with the\n *  position, in screen coordinates, relative to the upper-left corner of the\n *  content area of the window.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, double xpos, double ypos);\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWcursorposfun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref cursor_pos\n *\n *  @since Added in version 3.0.  Replaces `glfwSetMousePosCallback`.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetCursorPosCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, int)"}], :ret {:spelling "void (*)(struct GLFWwindow *, int)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int] :coffi.mem/void]], :symbol "glfwSetCursorEnterCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetCursorEnterCallback, :raw-comment "/*! @brief Sets the cursor enter/leave callback.\n *\n *  This function sets the cursor boundary crossing callback of the specified\n *  window, which is called when the cursor enters or leaves the content area of\n *  the window.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, int entered)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWcursorenterfun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref cursor_enter\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetCursorEnterCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, double, double)"}], :ret {:spelling "void (*)(struct GLFWwindow *, double, double)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/double :coffi.mem/double] :coffi.mem/void]], :symbol "glfwSetScrollCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/double :coffi.mem/double] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetScrollCallback, :raw-comment "/*! @brief Sets the scroll callback.\n *\n *  This function sets the scroll callback of the specified window, which is\n *  called when a scrolling device is used, such as a mouse wheel or scrolling\n *  area of a touchpad.\n *\n *  The scroll callback receives all scrolling input, like that from a mouse\n *  wheel or a touchpad scrolling area.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new scroll callback, or `NULL` to remove the\n *  currently set callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, double xoffset, double yoffset)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWscrollfun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref scrolling\n *\n *  @since Added in version 3.0.  Replaces `glfwSetMouseWheelCallback`.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetScrollCallback"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "callback", :type "void (*)(struct GLFWwindow *, int, const char **)"}], :ret {:spelling "void (*)(struct GLFWwindow *, int, const char **)"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]] :coffi.mem/void]], :symbol "glfwSetDropCallback", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/GLFWwindow] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetDropCallback, :raw-comment "/*! @brief Sets the path drop callback.\n *\n *  This function sets the path drop callback of the specified window, which is\n *  called when one or more dragged paths are dropped on the window.\n *\n *  Because the path array and its strings may have been generated specifically\n *  for that event, they are not guaranteed to be valid after the callback has\n *  returned.  If you wish to use them after the callback returns, you need to\n *  make a deep copy.\n *\n *  @param[in] window The window whose callback to set.\n *  @param[in] callback The new file drop callback, or `NULL` to remove the\n *  currently set callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(GLFWwindow* window, int path_count, const char* paths[])\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWdropfun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @remark @wayland File drop is currently unimplemented.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref path_drop\n *\n *  @since Added in version 3.1.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetDropCallback"} {:args [{:spelling "jid", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "glfwJoystickPresent", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwJoystickPresent, :raw-comment "/*! @brief Returns whether the specified joystick is present.\n *\n *  This function returns whether the specified joystick is present.\n *\n *  There is no need to call this function before other functions that accept\n *  a joystick ID, as they all check for presence before performing any other\n *  work.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @return `GLFW_TRUE` if the joystick is present, or `GLFW_FALSE` otherwise.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref joystick\n *\n *  @since Added in version 3.0.  Replaces `glfwGetJoystickParam`.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwJoystickPresent"} {:args [{:spelling "jid", :type "int"} {:spelling "count", :type "int *"}], :ret {:spelling "const float *"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glfwGetJoystickAxes", :function/ret [:coffi.mem/pointer :coffi.mem/float], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetJoystickAxes, :raw-comment "/*! @brief Returns the values of all axes of the specified joystick.\n *\n *  This function returns the values of all axes of the specified joystick.\n *  Each element in the array is a value between -1.0 and 1.0.\n *\n *  If the specified joystick is not present this function will return `NULL`\n *  but will not generate an error.  This can be used instead of first calling\n *  @ref glfwJoystickPresent.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @param[out] count Where to store the number of axis values in the returned\n *  array.  This is set to zero if the joystick is not present or an error\n *  occurred.\n *  @return An array of axis values, or `NULL` if the joystick is not present or\n *  an [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified joystick is\n *  disconnected or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref joystick_axis\n *\n *  @since Added in version 3.0.  Replaces `glfwGetJoystickPos`.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetJoystickAxes"} {:args [{:spelling "jid", :type "int"} {:spelling "count", :type "int *"}], :ret {:spelling "const unsigned char *"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glfwGetJoystickButtons", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetJoystickButtons, :raw-comment "/*! @brief Returns the state of all buttons of the specified joystick.\n *\n *  This function returns the state of all buttons of the specified joystick.\n *  Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.\n *\n *  For backward compatibility with earlier versions that did not have @ref\n *  glfwGetJoystickHats, the button array also includes all hats, each\n *  represented as four buttons.  The hats are in the same order as returned by\n *  __glfwGetJoystickHats__ and are in the order _up_, _right_, _down_ and\n *  _left_.  To disable these extra buttons, set the @ref\n *  GLFW_JOYSTICK_HAT_BUTTONS init hint before initialization.\n *\n *  If the specified joystick is not present this function will return `NULL`\n *  but will not generate an error.  This can be used instead of first calling\n *  @ref glfwJoystickPresent.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @param[out] count Where to store the number of button states in the returned\n *  array.  This is set to zero if the joystick is not present or an error\n *  occurred.\n *  @return An array of button states, or `NULL` if the joystick is not present\n *  or an [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified joystick is\n *  disconnected or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref joystick_button\n *\n *  @since Added in version 2.2.\n *  @glfw3 Changed to return a dynamic array.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetJoystickButtons"} {:args [{:spelling "jid", :type "int"} {:spelling "count", :type "int *"}], :ret {:spelling "const unsigned char *"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "glfwGetJoystickHats", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetJoystickHats, :raw-comment "/*! @brief Returns the state of all hats of the specified joystick.\n *\n *  This function returns the state of all hats of the specified joystick.\n *  Each element in the array is one of the following values:\n *\n *  Name                  | Value\n *  ----                  | -----\n *  `GLFW_HAT_CENTERED`   | 0\n *  `GLFW_HAT_UP`         | 1\n *  `GLFW_HAT_RIGHT`      | 2\n *  `GLFW_HAT_DOWN`       | 4\n *  `GLFW_HAT_LEFT`       | 8\n *  `GLFW_HAT_RIGHT_UP`   | `GLFW_HAT_RIGHT` \\| `GLFW_HAT_UP`\n *  `GLFW_HAT_RIGHT_DOWN` | `GLFW_HAT_RIGHT` \\| `GLFW_HAT_DOWN`\n *  `GLFW_HAT_LEFT_UP`    | `GLFW_HAT_LEFT` \\| `GLFW_HAT_UP`\n *  `GLFW_HAT_LEFT_DOWN`  | `GLFW_HAT_LEFT` \\| `GLFW_HAT_DOWN`\n *\n *  The diagonal directions are bitwise combinations of the primary (up, right,\n *  down and left) directions and you can test for these individually by ANDing\n *  it with the corresponding direction.\n *\n *  @code\n *  if (hats[2] & GLFW_HAT_RIGHT)\n *  {\n *      // State of hat 2 could be right-up, right or right-down\n *  }\n *  @endcode\n *\n *  If the specified joystick is not present this function will return `NULL`\n *  but will not generate an error.  This can be used instead of first calling\n *  @ref glfwJoystickPresent.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @param[out] count Where to store the number of hat states in the returned\n *  array.  This is set to zero if the joystick is not present or an error\n *  occurred.\n *  @return An array of hat states, or `NULL` if the joystick is not present\n *  or an [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified joystick is\n *  disconnected, this function is called again for that joystick or the library\n *  is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref joystick_hat\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetJoystickHats"} {:args [{:spelling "jid", :type "int"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "glfwGetJoystickName", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetJoystickName, :raw-comment "/*! @brief Returns the name of the specified joystick.\n *\n *  This function returns the name, encoded as UTF-8, of the specified joystick.\n *  The returned string is allocated and freed by GLFW.  You should not free it\n *  yourself.\n *\n *  If the specified joystick is not present this function will return `NULL`\n *  but will not generate an error.  This can be used instead of first calling\n *  @ref glfwJoystickPresent.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @return The UTF-8 encoded name of the joystick, or `NULL` if the joystick\n *  is not present or an [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified joystick is\n *  disconnected or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref joystick_name\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetJoystickName"} {:args [{:spelling "jid", :type "int"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "glfwGetJoystickGUID", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetJoystickGUID, :raw-comment "/*! @brief Returns the SDL compatible GUID of the specified joystick.\n *\n *  This function returns the SDL compatible GUID, as a UTF-8 encoded\n *  hexadecimal string, of the specified joystick.  The returned string is\n *  allocated and freed by GLFW.  You should not free it yourself.\n *\n *  The GUID is what connects a joystick to a gamepad mapping.  A connected\n *  joystick will always have a GUID even if there is no gamepad mapping\n *  assigned to it.\n *\n *  If the specified joystick is not present this function will return `NULL`\n *  but will not generate an error.  This can be used instead of first calling\n *  @ref glfwJoystickPresent.\n *\n *  The GUID uses the format introduced in SDL 2.0.5.  This GUID tries to\n *  uniquely identify the make and model of a joystick but does not identify\n *  a specific unit, e.g. all wired Xbox 360 controllers will have the same\n *  GUID on that platform.  The GUID for a unit may vary between platforms\n *  depending on what hardware information the platform specific APIs provide.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @return The UTF-8 encoded GUID of the joystick, or `NULL` if the joystick\n *  is not present or an [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified joystick is\n *  disconnected or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref gamepad\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetJoystickGUID"} {:args [{:spelling "jid", :type "int"} {:spelling "pointer", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int :coffi.mem/pointer], :symbol "glfwSetJoystickUserPointer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetJoystickUserPointer, :raw-comment "/*! @brief Sets the user pointer of the specified joystick.\n *\n *  This function sets the user-defined pointer of the specified joystick.  The\n *  current value is retained until the joystick is disconnected.  The initial\n *  value is `NULL`.\n *\n *  This function may be called from the joystick callback, even for a joystick\n *  that is being disconnected.\n *\n *  @param[in] jid The joystick whose pointer to set.\n *  @param[in] pointer The new value.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref joystick_userptr\n *  @sa @ref glfwGetJoystickUserPointer\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetJoystickUserPointer"} {:args [{:spelling "jid", :type "int"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/int], :symbol "glfwGetJoystickUserPointer", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetJoystickUserPointer, :raw-comment "/*! @brief Returns the user pointer of the specified joystick.\n *\n *  This function returns the current value of the user-defined pointer of the\n *  specified joystick.  The initial value is `NULL`.\n *\n *  This function may be called from the joystick callback, even for a joystick\n *  that is being disconnected.\n *\n *  @param[in] jid The joystick whose pointer to return.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref joystick_userptr\n *  @sa @ref glfwSetJoystickUserPointer\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetJoystickUserPointer"} {:args [{:spelling "jid", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "glfwJoystickIsGamepad", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwJoystickIsGamepad, :raw-comment "/*! @brief Returns whether the specified joystick has a gamepad mapping.\n *\n *  This function returns whether the specified joystick is both present and has\n *  a gamepad mapping.\n *\n *  If the specified joystick is present but does not have a gamepad mapping\n *  this function will return `GLFW_FALSE` but will not generate an error.  Call\n *  @ref glfwJoystickPresent to check if a joystick is present regardless of\n *  whether it has a mapping.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @return `GLFW_TRUE` if a joystick is both present and has a gamepad mapping,\n *  or `GLFW_FALSE` otherwise.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_ENUM.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref gamepad\n *  @sa @ref glfwGetGamepadState\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwJoystickIsGamepad"} {:args [{:spelling "callback", :type "void (*)(int, int)"}], :ret {:spelling "void (*)(int, int)"}, :function/args [[:coffi.ffi/fn [:coffi.mem/int :coffi.mem/int] :coffi.mem/void]], :symbol "glfwSetJoystickCallback", :function/ret [:coffi.ffi/fn [:coffi.mem/int :coffi.mem/int] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetJoystickCallback, :raw-comment "/*! @brief Sets the joystick configuration callback.\n *\n *  This function sets the joystick configuration callback, or removes the\n *  currently set callback.  This is called when a joystick is connected to or\n *  disconnected from the system.\n *\n *  For joystick connection and disconnection events to be delivered on all\n *  platforms, you need to call one of the [event processing](@ref events)\n *  functions.  Joystick disconnection may also be detected and the callback\n *  called by joystick functions.  The function will then return whatever it\n *  returns if the joystick is not present.\n *\n *  @param[in] callback The new callback, or `NULL` to remove the currently set\n *  callback.\n *  @return The previously set callback, or `NULL` if no callback was set or the\n *  library had not been [initialized](@ref intro_init).\n *\n *  @callback_signature\n *  @code\n *  void function_name(int jid, int event)\n *  @endcode\n *  For more information about the callback parameters, see the\n *  [function pointer type](@ref GLFWjoystickfun).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref joystick_event\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetJoystickCallback"} {:args [{:spelling "string", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "glfwUpdateGamepadMappings", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwUpdateGamepadMappings, :raw-comment "/*! @brief Adds the specified SDL_GameControllerDB gamepad mappings.\n *\n *  This function parses the specified ASCII encoded string and updates the\n *  internal list with any gamepad mappings it finds.  This string may\n *  contain either a single gamepad mapping or many mappings separated by\n *  newlines.  The parser supports the full format of the `gamecontrollerdb.txt`\n *  source file including empty lines and comments.\n *\n *  See @ref gamepad_mapping for a description of the format.\n *\n *  If there is already a gamepad mapping for a given GUID in the internal list,\n *  it will be replaced by the one passed to this function.  If the library is\n *  terminated and re-initialized the internal list will revert to the built-in\n *  default.\n *\n *  @param[in] string The string containing the gamepad mappings.\n *  @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_VALUE.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref gamepad\n *  @sa @ref glfwJoystickIsGamepad\n *  @sa @ref glfwGetGamepadName\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwUpdateGamepadMappings"} {:args [{:spelling "jid", :type "int"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "glfwGetGamepadName", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetGamepadName, :raw-comment "/*! @brief Returns the human-readable gamepad name for the specified joystick.\n *\n *  This function returns the human-readable name of the gamepad from the\n *  gamepad mapping assigned to the specified joystick.\n *\n *  If the specified joystick is not present or does not have a gamepad mapping\n *  this function will return `NULL` but will not generate an error.  Call\n *  @ref glfwJoystickPresent to check whether it is present regardless of\n *  whether it has a mapping.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @return The UTF-8 encoded name of the gamepad, or `NULL` if the\n *  joystick is not present, does not have a mapping or an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref GLFW_INVALID_ENUM.\n *\n *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified joystick is\n *  disconnected, the gamepad mappings are updated or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref gamepad\n *  @sa @ref glfwJoystickIsGamepad\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetGamepadName"} {:args [{:spelling "jid", :type "int"} {:spelling "state", :type "struct GLFWgamepadstate *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :clong/GLFWgamepadstate]], :symbol "glfwGetGamepadState", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetGamepadState, :raw-comment "/*! @brief Retrieves the state of the specified joystick remapped as a gamepad.\n *\n *  This function retrieves the state of the specified joystick remapped to\n *  an Xbox-like gamepad.\n *\n *  If the specified joystick is not present or does not have a gamepad mapping\n *  this function will return `GLFW_FALSE` but will not generate an error.  Call\n *  @ref glfwJoystickPresent to check whether it is present regardless of\n *  whether it has a mapping.\n *\n *  The Guide button may not be available for input as it is often hooked by the\n *  system or the Steam client.\n *\n *  Not all devices have all the buttons or axes provided by @ref\n *  GLFWgamepadstate.  Unavailable buttons and axes will always report\n *  `GLFW_RELEASE` and 0.0 respectively.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @param[out] state The gamepad input state of the joystick.\n *  @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if no joystick is\n *  connected, it has no gamepad mapping or an [error](@ref error_handling)\n *  occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_ENUM.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref gamepad\n *  @sa @ref glfwUpdateGamepadMappings\n *  @sa @ref glfwJoystickIsGamepad\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetGamepadState"} {:args [{:spelling "window", :type "struct GLFWwindow *"} {:spelling "string", :type "const char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow] [:coffi.mem/pointer :coffi.mem/char]], :symbol "glfwSetClipboardString", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetClipboardString, :raw-comment "/*! @brief Sets the clipboard to the specified string.\n *\n *  This function sets the system clipboard to the specified, UTF-8 encoded\n *  string.\n *\n *  @param[in] window Deprecated.  Any valid window or `NULL`.\n *  @param[in] string A UTF-8 encoded string.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The specified string is copied before this function\n *  returns.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref clipboard\n *  @sa @ref glfwGetClipboardString\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetClipboardString"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "const char *"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwGetClipboardString", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetClipboardString, :raw-comment "/*! @brief Returns the contents of the clipboard as a string.\n *\n *  This function returns the contents of the system clipboard, if it contains\n *  or is convertible to a UTF-8 encoded string.  If the clipboard is empty or\n *  if its contents cannot be converted, `NULL` is returned and a @ref\n *  GLFW_FORMAT_UNAVAILABLE error is generated.\n *\n *  @param[in] window Deprecated.  Any valid window or `NULL`.\n *  @return The contents of the clipboard as a UTF-8 encoded string, or `NULL`\n *  if an [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_FORMAT_UNAVAILABLE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the next call to @ref\n *  glfwGetClipboardString or @ref glfwSetClipboardString, or until the library\n *  is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref clipboard\n *  @sa @ref glfwSetClipboardString\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetClipboardString"} {:args [], :ret {:spelling "double"}, :function/args [], :symbol "glfwGetTime", :function/ret :coffi.mem/double, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetTime, :raw-comment "/*! @brief Returns the GLFW time.\n *\n *  This function returns the current GLFW time, in seconds.  Unless the time\n *  has been set using @ref glfwSetTime it measures time elapsed since GLFW was\n *  initialized.\n *\n *  This function and @ref glfwSetTime are helper functions on top of @ref\n *  glfwGetTimerFrequency and @ref glfwGetTimerValue.\n *\n *  The resolution of the timer is system dependent, but is usually on the order\n *  of a few micro- or nanoseconds.  It uses the highest-resolution monotonic\n *  time source on each supported platform.\n *\n *  @return The current time, in seconds, or zero if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Reading and\n *  writing of the internal base time is not atomic, so it needs to be\n *  externally synchronized with calls to @ref glfwSetTime.\n *\n *  @sa @ref time\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetTime"} {:args [{:spelling "time", :type "double"}], :ret {:spelling "void"}, :function/args [:coffi.mem/double], :symbol "glfwSetTime", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSetTime, :raw-comment "/*! @brief Sets the GLFW time.\n *\n *  This function sets the current GLFW time, in seconds.  The value must be\n *  a positive finite number less than or equal to 18446744073.0, which is\n *  approximately 584.5 years.\n *\n *  This function and @ref glfwGetTime are helper functions on top of @ref\n *  glfwGetTimerFrequency and @ref glfwGetTimerValue.\n *\n *  @param[in] time The new value, in seconds.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_VALUE.\n *\n *  @remark The upper limit of GLFW time is calculated as\n *  floor((2<sup>64</sup> - 1) / 10<sup>9</sup>) and is due to implementations\n *  storing nanoseconds in 64 bits.  The limit may be increased in the future.\n *\n *  @thread_safety This function may be called from any thread.  Reading and\n *  writing of the internal base time is not atomic, so it needs to be\n *  externally synchronized with calls to @ref glfwGetTime.\n *\n *  @sa @ref time\n *\n *  @since Added in version 2.2.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSetTime"} {:args [], :ret {:spelling "unsigned long long"}, :function/args [], :symbol "glfwGetTimerValue", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetTimerValue, :raw-comment "/*! @brief Returns the current value of the raw timer.\n *\n *  This function returns the current value of the raw timer, measured in\n *  1&nbsp;/&nbsp;frequency seconds.  To get the frequency, call @ref\n *  glfwGetTimerFrequency.\n *\n *  @return The value of the timer, or zero if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref time\n *  @sa @ref glfwGetTimerFrequency\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetTimerValue"} {:args [], :ret {:spelling "unsigned long long"}, :function/args [], :symbol "glfwGetTimerFrequency", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetTimerFrequency, :raw-comment "/*! @brief Returns the frequency, in Hz, of the raw timer.\n *\n *  This function returns the frequency, in Hz, of the raw timer.\n *\n *  @return The frequency of the timer, in Hz, or zero if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref time\n *  @sa @ref glfwGetTimerValue\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup input\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetTimerFrequency"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwMakeContextCurrent", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwMakeContextCurrent, :raw-comment "/*! @brief Makes the context of the specified window current for the calling\n *  thread.\n *\n *  This function makes the OpenGL or OpenGL ES context of the specified window\n *  current on the calling thread.  A context must only be made current on\n *  a single thread at a time and each thread can have only a single current\n *  context at a time.\n *\n *  When moving a context between threads, you must make it non-current on the\n *  old thread before making it current on the new one.\n *\n *  By default, making a context non-current implicitly forces a pipeline flush.\n *  On machines that support `GL_KHR_context_flush_control`, you can control\n *  whether a context performs this flush by setting the\n *  [GLFW_CONTEXT_RELEASE_BEHAVIOR](@ref GLFW_CONTEXT_RELEASE_BEHAVIOR_hint)\n *  hint.\n *\n *  The specified window must have an OpenGL or OpenGL ES context.  Specifying\n *  a window without a context will generate a @ref GLFW_NO_WINDOW_CONTEXT\n *  error.\n *\n *  @param[in] window The window whose context to make current, or `NULL` to\n *  detach the current context.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_NO_WINDOW_CONTEXT and @ref GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref context_current\n *  @sa @ref glfwGetCurrentContext\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup context\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwMakeContextCurrent"} {:args [], :ret {:spelling "struct GLFWwindow *"}, :function/args [], :symbol "glfwGetCurrentContext", :function/ret [:coffi.mem/pointer :clong/GLFWwindow], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetCurrentContext, :raw-comment "/*! @brief Returns the window whose context is current on the calling thread.\n *\n *  This function returns the window whose OpenGL or OpenGL ES context is\n *  current on the calling thread.\n *\n *  @return The window whose context is current, or `NULL` if no window's\n *  context is current.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref context_current\n *  @sa @ref glfwMakeContextCurrent\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup context\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetCurrentContext"} {:args [{:spelling "window", :type "struct GLFWwindow *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/GLFWwindow]], :symbol "glfwSwapBuffers", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSwapBuffers, :raw-comment "/*! @brief Swaps the front and back buffers of the specified window.\n *\n *  This function swaps the front and back buffers of the specified window when\n *  rendering with OpenGL or OpenGL ES.  If the swap interval is greater than\n *  zero, the GPU driver waits the specified number of screen updates before\n *  swapping the buffers.\n *\n *  The specified window must have an OpenGL or OpenGL ES context.  Specifying\n *  a window without a context will generate a @ref GLFW_NO_WINDOW_CONTEXT\n *  error.\n *\n *  This function does not apply to Vulkan.  If you are rendering with Vulkan,\n *  see `vkQueuePresentKHR` instead.\n *\n *  @param[in] window The window whose buffers to swap.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_NO_WINDOW_CONTEXT and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark __EGL:__ The context of the specified window must be current on the\n *  calling thread.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref buffer_swap\n *  @sa @ref glfwSwapInterval\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup window\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSwapBuffers"} {:args [{:spelling "interval", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "glfwSwapInterval", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwSwapInterval, :raw-comment "/*! @brief Sets the swap interval for the current context.\n *\n *  This function sets the swap interval for the current OpenGL or OpenGL ES\n *  context, i.e. the number of screen updates to wait from the time @ref\n *  glfwSwapBuffers was called before swapping the buffers and returning.  This\n *  is sometimes called _vertical synchronization_, _vertical retrace\n *  synchronization_ or just _vsync_.\n *\n *  A context that supports either of the `WGL_EXT_swap_control_tear` and\n *  `GLX_EXT_swap_control_tear` extensions also accepts _negative_ swap\n *  intervals, which allows the driver to swap immediately even if a frame\n *  arrives a little bit late.  You can check for these extensions with @ref\n *  glfwExtensionSupported.\n *\n *  A context must be current on the calling thread.  Calling this function\n *  without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error.\n *\n *  This function does not apply to Vulkan.  If you are rendering with Vulkan,\n *  see the present mode of your swapchain instead.\n *\n *  @param[in] interval The minimum number of screen updates to wait for\n *  until the buffers are swapped by @ref glfwSwapBuffers.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_NO_CURRENT_CONTEXT and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark This function is not called during context creation, leaving the\n *  swap interval set to whatever is the default on that platform.  This is done\n *  because some swap interval extensions used by GLFW do not allow the swap\n *  interval to be reset to zero once it has been set to a non-zero value.\n *\n *  @remark Some GPU drivers do not honor the requested swap interval, either\n *  because of a user setting that overrides the application's request or due to\n *  bugs in the driver.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref buffer_swap\n *  @sa @ref glfwSwapBuffers\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup context\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwSwapInterval"} {:args [{:spelling "extension", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "glfwExtensionSupported", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwExtensionSupported, :raw-comment "/*! @brief Returns whether the specified extension is available.\n *\n *  This function returns whether the specified\n *  [API extension](@ref context_glext) is supported by the current OpenGL or\n *  OpenGL ES context.  It searches both for client API extension and context\n *  creation API extensions.\n *\n *  A context must be current on the calling thread.  Calling this function\n *  without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error.\n *\n *  As this functions retrieves and searches one or more extension strings each\n *  call, it is recommended that you cache its results if it is going to be used\n *  frequently.  The extension strings will not change during the lifetime of\n *  a context, so there is no danger in doing this.\n *\n *  This function does not apply to Vulkan.  If you are using Vulkan, see @ref\n *  glfwGetRequiredInstanceExtensions, `vkEnumerateInstanceExtensionProperties`\n *  and `vkEnumerateDeviceExtensionProperties` instead.\n *\n *  @param[in] extension The ASCII encoded name of the extension.\n *  @return `GLFW_TRUE` if the extension is available, or `GLFW_FALSE`\n *  otherwise.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_NO_CURRENT_CONTEXT, @ref GLFW_INVALID_VALUE and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref context_glext\n *  @sa @ref glfwGetProcAddress\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup context\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwExtensionSupported"} {:args [{:spelling "procname", :type "const char *"}], :ret {:spelling "void (*)(void)"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "glfwGetProcAddress", :function/ret [:coffi.ffi/fn [] :coffi.mem/void], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetProcAddress, :raw-comment "/*! @brief Returns the address of the specified function for the current\n *  context.\n *\n *  This function returns the address of the specified OpenGL or OpenGL ES\n *  [core or extension function](@ref context_glext), if it is supported\n *  by the current context.\n *\n *  A context must be current on the calling thread.  Calling this function\n *  without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error.\n *\n *  This function does not apply to Vulkan.  If you are rendering with Vulkan,\n *  see @ref glfwGetInstanceProcAddress, `vkGetInstanceProcAddr` and\n *  `vkGetDeviceProcAddr` instead.\n *\n *  @param[in] procname The ASCII encoded name of the function.\n *  @return The address of the function, or `NULL` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_NO_CURRENT_CONTEXT and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark The address of a given function is not guaranteed to be the same\n *  between contexts.\n *\n *  @remark This function may return a non-`NULL` address despite the\n *  associated version or extension not being available.  Always check the\n *  context version or extension string first.\n *\n *  @pointer_lifetime The returned function pointer is valid until the context\n *  is destroyed or the library is terminated.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref context_glext\n *  @sa @ref glfwExtensionSupported\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup context\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetProcAddress"} {:args [], :ret {:spelling "int"}, :function/args [], :symbol "glfwVulkanSupported", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwVulkanSupported, :raw-comment "/*! @brief Returns whether the Vulkan loader and an ICD have been found.\n *\n *  This function returns whether the Vulkan loader and any minimally functional\n *  ICD have been found.\n *\n *  The availability of a Vulkan loader and even an ICD does not by itself guarantee that\n *  surface creation or even instance creation is possible.  Call @ref\n *  glfwGetRequiredInstanceExtensions to check whether the extensions necessary for Vulkan\n *  surface creation are available and @ref glfwGetPhysicalDevicePresentationSupport to\n *  check whether a queue family of a physical device supports image presentation.\n *\n *  @return `GLFW_TRUE` if Vulkan is minimally available, or `GLFW_FALSE`\n *  otherwise.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref vulkan_support\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup vulkan\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwVulkanSupported"} {:args [{:spelling "count", :type "unsigned int *"}], :ret {:spelling "const char **"}, :function/args [[:coffi.mem/pointer :coffi.mem/int]], :symbol "glfwGetRequiredInstanceExtensions", :function/ret [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :glfwGetRequiredInstanceExtensions, :raw-comment "/*! @brief Returns the Vulkan instance extensions required by GLFW.\n *\n *  This function returns an array of names of Vulkan instance extensions required\n *  by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the\n *  list will always contain `VK_KHR_surface`, so if you don't require any\n *  additional extensions you can pass this list directly to the\n *  `VkInstanceCreateInfo` struct.\n *\n *  If Vulkan is not available on the machine, this function returns `NULL` and\n *  generates a @ref GLFW_API_UNAVAILABLE error.  Call @ref glfwVulkanSupported\n *  to check whether Vulkan is at least minimally available.\n *\n *  If Vulkan is available but no set of extensions allowing window surface\n *  creation was found, this function returns `NULL`.  You may still use Vulkan\n *  for off-screen rendering and compute work.\n *\n *  @param[out] count Where to store the number of extensions in the returned\n *  array.  This is set to zero if an error occurred.\n *  @return An array of ASCII encoded extension names, or `NULL` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_API_UNAVAILABLE.\n *\n *  @remark Additional extensions may be required by future versions of GLFW.\n *  You should check if any extensions you wish to enable are already in the\n *  returned array, as it is an error to specify an extension more than once in\n *  the `VkInstanceCreateInfo` struct.\n *\n *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is guaranteed to be valid only until the\n *  library is terminated.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref vulkan_ext\n *  @sa @ref glfwCreateWindowSurface\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup vulkan\n */", :kind "CXCursor_FunctionDecl", :spelling "glfwGetRequiredInstanceExtensions"}), :structs ({:kind "CXCursor_StructDecl", :spelling "struct GLFWgammaramp", :type "CXType_Record", :id :clong/GLFWgammaramp, :size-in-bytes 32, :fields [{:type "unsigned short *", :datatype [:coffi.mem/pointer :coffi.mem/short], :name "red", :calculated-offset 0} {:type "unsigned short *", :datatype [:coffi.mem/pointer :coffi.mem/short], :name "green", :calculated-offset 64} {:type "unsigned short *", :datatype [:coffi.mem/pointer :coffi.mem/short], :name "blue", :calculated-offset 128} {:type "unsigned int", :datatype :coffi.mem/int, :name "size", :calculated-offset 192}]} {:kind "CXCursor_StructDecl", :spelling "struct GLFWvidmode", :type "CXType_Record", :id :clong/GLFWvidmode, :size-in-bytes 24, :fields [{:type "int", :datatype :coffi.mem/int, :name "width", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "height", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "redBits", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "greenBits", :calculated-offset 96} {:type "int", :datatype :coffi.mem/int, :name "blueBits", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "refreshRate", :calculated-offset 160}]} {:kind "CXCursor_StructDecl", :spelling "struct GLFWimage", :type "CXType_Record", :id :clong/GLFWimage, :size-in-bytes 16, :fields [{:type "int", :datatype :coffi.mem/int, :name "width", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "height", :calculated-offset 32} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "pixels", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :spelling "struct GLFWgamepadstate", :type "CXType_Record", :id :clong/GLFWgamepadstate, :size-in-bytes 40, :fields [{:type "unsigned char [15]", :datatype [:coffi.mem/array :coffi.mem/char 15], :name "buttons", :calculated-offset 0} {:type "float [6]", :datatype [:coffi.mem/array :coffi.mem/float 6], :name "axes", :calculated-offset 128}]}), :enums ()}